-- Supabase security patch for TCC
-- Goal: enable RLS on all app tables and enforce role-based access without a custom backend.
--
-- IMPORTANT:
-- 1) This setup expects Supabase Auth sessions (auth.uid()/JWT) for normal data access.
-- 2) Legacy localStorage-only sessions are not secure and are intentionally restricted.
-- 3) Run this script in Supabase SQL Editor as a privileged role.

create extension if not exists pgcrypto with schema extensions;
create extension if not exists pg_cron with schema extensions;

-- ---------------------------------------------------------------------------
-- Privileges baseline
-- ---------------------------------------------------------------------------
grant usage on schema public to anon, authenticated;

revoke all on all tables in schema public from anon;
grant select, insert, update, delete on all tables in schema public to authenticated;

revoke usage, select on all sequences in schema public from anon;
grant usage, select on all sequences in schema public to authenticated;

alter default privileges in schema public revoke all on tables from anon;
alter default privileges in schema public grant select, insert, update, delete on tables to authenticated;
alter default privileges in schema public revoke usage, select on sequences from anon;
alter default privileges in schema public grant usage, select on sequences to authenticated;

-- ---------------------------------------------------------------------------
-- Users table auth linkage
-- ---------------------------------------------------------------------------
alter table if exists public.users add column if not exists auth_uid uuid;
alter table if exists public.users add column if not exists expires_at timestamptz;
create unique index if not exists idx_users_auth_uid
  on public.users(auth_uid)
  where auth_uid is not null;
create index if not exists idx_users_expires_at
  on public.users(expires_at)
  where expires_at is not null;
create index if not exists idx_users_username_lower
  on public.users((lower(username)));

create table if not exists public.status_logs (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  actor_user_id bigint,
  actor_username text,
  actor_role text,
  action text not null,
  category text not null default 'general',
  target_user_id bigint,
  target_username text,
  target_role text,
  message text not null,
  metadata jsonb not null default '{}'::jsonb
);

create index if not exists idx_status_logs_created_at
  on public.status_logs(created_at desc);
create index if not exists idx_status_logs_action
  on public.status_logs(action);
create index if not exists idx_status_logs_category
  on public.status_logs(category);
create index if not exists idx_status_logs_actor_role
  on public.status_logs(actor_role);
create index if not exists idx_status_logs_target_role
  on public.status_logs(target_role);

create table if not exists public.account_requests (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  request_type text not null,
  status text not null default 'pending',
  requester_user_id bigint not null,
  requester_username text,
  requester_full_name text,
  requester_role text,
  note text,
  resolved_by_user_id bigint,
  resolved_at timestamptz
);

create index if not exists idx_account_requests_status
  on public.account_requests(status);
create index if not exists idx_account_requests_type
  on public.account_requests(request_type);
create index if not exists idx_account_requests_requester
  on public.account_requests(requester_user_id);

-- Never expose password hashes to client roles.
do $$
begin 
  if exists (
    select 1
    from information_schema.columns
    where table_schema = 'public'
      and table_name = 'users'
      and column_name = 'password'
  ) then
    execute 'revoke select (password) on public.users from anon, authenticated';
  end if;
end $$;

-- ---------------------------------------------------------------------------
-- Helper functions used by RLS policies
-- ---------------------------------------------------------------------------
create or replace function public.app_current_user_id()
returns bigint
language sql
stable
security definer
set search_path = public
as $$
  select u.id
  from public.users u
  where auth.uid() is not null
    and u.auth_uid = auth.uid()
    and (u.expires_at is null or u.expires_at > now())
  order by u.id
  limit 1;
$$;

create or replace function public.app_has_role(p_role text)
returns boolean
language sql
stable
security definer
set search_path = public
as $$
  select exists (
    select 1
    from public.users u
    where u.id = public.app_current_user_id()
      and (
        lower(coalesce(u.role, '')) = lower(coalesce(p_role, ''))
        or coalesce(u.roles, '[]'::jsonb) ? lower(coalesce(p_role, ''))
        or lower(coalesce(u.sub_role, '')) = lower(coalesce(p_role, ''))
        or coalesce(u.sub_roles, '[]'::jsonb) ? lower(coalesce(p_role, ''))
      )
  );
$$;

create or replace function public.app_is_admin()
returns boolean
language sql
stable
as $$ select public.app_has_role('admin'); $$;

create or replace function public.app_is_teacher()
returns boolean
language sql
stable
as $$ select public.app_has_role('teacher'); $$;

create or replace function public.app_is_student()
returns boolean
language sql
stable
as $$ select public.app_has_role('student'); $$;

create or replace function public.app_is_staff()
returns boolean
language sql
stable
as $$
  select
    public.app_has_role('nt')
    or public.app_has_role('osas')
    or public.app_has_role('treasury')
    or public.app_has_role('faculty');
$$;

create or replace function public.app_bind_auth_uid_for_user(
  p_user_id bigint
)
returns table (
  id bigint,
  auth_uid uuid
)
language sql
security definer
set search_path = public
as $$
  update public.users u
     set auth_uid = auth.uid(),
         updated_at = now()
   where auth.uid() is not null
     and u.id = p_user_id
     and (u.auth_uid is null or u.auth_uid = auth.uid())
  returning u.id, u.auth_uid;
$$;

create or replace function public.app_ensure_auth_user_for_password(
  p_user_id bigint,
  p_password text
)
returns table (
  auth_uid uuid,
  auth_email text,
  auth_synced boolean,
  created_auth_user boolean
)
language plpgsql
security definer
set search_path = public, auth, extensions
as $$
declare
  v_user public.users%rowtype;
  v_auth_uid uuid;
  v_auth_email text;
  v_instance_id uuid := '00000000-0000-0000-0000-000000000000'::uuid;
  v_created_auth_user boolean := false;
  v_synced boolean := false;
begin
  if coalesce(p_user_id, 0) <= 0 then
    raise exception 'Invalid user id.';
  end if;

  if length(coalesce(p_password, '')) < 8 then
    raise exception 'Password must be at least 8 characters.';
  end if;

  select *
    into v_user
  from public.users u
  where u.id = p_user_id
  limit 1;

  if not found then
    raise exception 'User not found.';
  end if;

  v_auth_uid := v_user.auth_uid;
  v_auth_email := lower(trim(coalesce(v_user.email, '')));

  if v_auth_uid is not null then
    perform 1
    from auth.users au
    where au.id = v_auth_uid;
    if not found then
      v_auth_uid := null;
    end if;
  end if;

  if v_auth_uid is null and v_auth_email <> '' then
    select au.id
      into v_auth_uid
    from auth.users au
    where lower(coalesce(au.email, '')) = v_auth_email
    order by au.created_at
    limit 1;
  end if;

  if v_auth_email = '' then
    v_auth_email := lower(trim(regexp_replace(coalesce(v_user.username, 'user'), '[^a-zA-Z0-9._-]+', '.', 'g')));
    v_auth_email := trim(both '.' from v_auth_email);
    if v_auth_email = '' then
      v_auth_email := format('user%s', p_user_id);
    end if;
    v_auth_email := v_auth_email || '@local.tcc';
  end if;

  if v_auth_uid is null then
    begin
      select i.id
        into v_instance_id
      from auth.instances i
      limit 1;
    exception
      when undefined_table then
        v_instance_id := '00000000-0000-0000-0000-000000000000'::uuid;
    end;

    v_auth_uid := gen_random_uuid();

    begin
      insert into auth.users (
        id,
        instance_id,
        aud,
        role,
        email,
        encrypted_password,
        email_confirmed_at,
        raw_app_meta_data,
        raw_user_meta_data,
        created_at,
        updated_at
      )
      values (
        v_auth_uid,
        v_instance_id,
        'authenticated',
        'authenticated',
        v_auth_email,
        crypt(p_password, gen_salt('bf', 10)),
        now(),
        '{"provider":"email","providers":["email"]}'::jsonb,
        '{}'::jsonb,
        now(),
        now()
      );
      v_created_auth_user := true;
    exception
      when unique_violation then
        select au.id
          into v_auth_uid
        from auth.users au
        where lower(coalesce(au.email, '')) = v_auth_email
        order by au.created_at
        limit 1;
        if v_auth_uid is null then
          raise;
        end if;
    end;

    begin
      insert into auth.identities (
        id,
        user_id,
        provider_id,
        identity_data,
        provider,
        last_sign_in_at,
        created_at,
        updated_at
      )
      values (
        gen_random_uuid(),
        v_auth_uid,
        v_auth_uid::text,
        jsonb_build_object(
          'sub', v_auth_uid::text,
          'email', v_auth_email,
          'email_verified', true,
          'phone_verified', false
        ),
        'email',
        now(),
        now(),
        now()
      )
      on conflict do nothing;
    exception
      when undefined_table or undefined_column then
        null;
    end;
  end if;

  update auth.users au
     set encrypted_password = crypt(p_password, gen_salt('bf', 10)),
         email = coalesce(nullif(v_auth_email, ''), au.email),
         email_confirmed_at = coalesce(au.email_confirmed_at, now()),
         updated_at = now()
   where au.id = v_auth_uid;
  v_synced := found;

  update public.users
     set auth_uid = v_auth_uid,
         email = coalesce(nullif(trim(coalesce(email, '')), ''), nullif(v_auth_email, '')),
         updated_at = now()
   where id = p_user_id;

  return query
  select
    v_auth_uid,
    nullif(v_auth_email, ''),
    coalesce(v_synced, false),
    coalesce(v_created_auth_user, false);
end;
$$;

create or replace function public.app_log_status_event(
  p_action text,
  p_category text default 'general',
  p_message text default null,
  p_actor_user_id bigint default null,
  p_actor_username text default null,
  p_actor_role text default null,
  p_target_user_id bigint default null,
  p_target_username text default null,
  p_target_role text default null,
  p_metadata jsonb default '{}'::jsonb
)
returns bigint
language plpgsql
security definer
set search_path = public
as $$
declare
  v_action text := lower(trim(coalesce(p_action, '')));
  v_category text := lower(trim(coalesce(p_category, 'general')));
  v_message text := nullif(trim(coalesce(p_message, '')), '');
  v_actor_user_id bigint := p_actor_user_id;
  v_actor_username text := nullif(trim(coalesce(p_actor_username, '')), '');
  v_actor_role text := lower(trim(coalesce(p_actor_role, '')));
  v_target_user_id bigint := p_target_user_id;
  v_target_username text := nullif(trim(coalesce(p_target_username, '')), '');
  v_target_role text := lower(trim(coalesce(p_target_role, '')));
  v_metadata jsonb := coalesce(p_metadata, '{}'::jsonb);
  v_id bigint;
begin
  if v_action = '' then
    raise exception 'Action is required.';
  end if;

  if v_category = '' then
    v_category := 'general';
  end if;

  if v_actor_user_id is null then
    v_actor_user_id := public.app_current_user_id();
  end if;

  if v_actor_user_id is not null and (v_actor_username is null or v_actor_role = '') then
    select
      coalesce(v_actor_username, nullif(trim(coalesce(u.username, '')), '')),
      coalesce(nullif(v_actor_role, ''), lower(trim(coalesce(u.role, ''))))
    into v_actor_username, v_actor_role
    from public.users u
    where u.id = v_actor_user_id
    limit 1;
  end if;

  if v_target_user_id is not null and (v_target_username is null or v_target_role = '') then
    select
      coalesce(v_target_username, nullif(trim(coalesce(u.username, '')), '')),
      coalesce(nullif(v_target_role, ''), lower(trim(coalesce(u.role, ''))))
    into v_target_username, v_target_role
    from public.users u
    where u.id = v_target_user_id
    limit 1;
  end if;

  if v_actor_role = '' then
    v_actor_role := null;
  end if;
  if v_target_role = '' then
    v_target_role := null;
  end if;

  if v_message is null then
    v_message := format('Event: %s', v_action);
  end if;

  insert into public.status_logs (
    actor_user_id,
    actor_username,
    actor_role,
    action,
    category,
    target_user_id,
    target_username,
    target_role,
    message,
    metadata
  )
  values (
    v_actor_user_id,
    v_actor_username,
    v_actor_role,
    v_action,
    v_category,
    v_target_user_id,
    v_target_username,
    v_target_role,
    v_message,
    v_metadata
  )
  returning id into v_id;

  return v_id;
end;
$$;

create or replace function public.app_purge_expired_users()
returns integer
language plpgsql
security definer
set search_path = public
as $$
declare
  v_deleted_count integer := 0;
  v_user_id bigint;
  v_username text;
  v_full_name text;
  v_role text;
  v_expires_at timestamptz;
begin
  for v_user_id, v_username, v_full_name, v_role, v_expires_at in
    select u.id, u.username, u.full_name, u.role, u.expires_at
    from public.users u
    where u.expires_at is not null
      and u.expires_at <= now()
  loop
    perform public.app_log_status_event(
      p_action => 'account_expired_auto_delete',
      p_category => 'system',
      p_message => format(
        'Expired account "%s" was deleted automatically.',
        coalesce(v_full_name, v_username, v_user_id::text)
      ),
      p_actor_user_id => null,
      p_actor_username => 'system',
      p_actor_role => 'system',
      p_target_user_id => v_user_id,
      p_target_username => v_username,
      p_target_role => lower(coalesce(v_role, '')),
      p_metadata => jsonb_build_object(
        'expires_at', v_expires_at,
        'source', 'pg_cron'
      )
    );

    delete from public.user_assignments where user_id = v_user_id;
    delete from public.teacher_assignments where teacher_id = v_user_id;
    delete from public.grades where student_id = v_user_id;
    delete from public.grades where teacher_id = v_user_id;
    delete from public.teacher_evaluations where student_id = v_user_id;
    delete from public.teacher_evaluations where teacher_id = v_user_id;
    delete from public.announcements where author_id = v_user_id;
    delete from public.feedbacks where student_id = v_user_id;
    update public.feedbacks set replied_by = null where replied_by = v_user_id;
    delete from public.users where id = v_user_id;
    v_deleted_count := v_deleted_count + 1;
  end loop;

  return v_deleted_count;
end;
$$;

create or replace function public.app_request_password_reset(
  p_note text default null
)
returns table (
  id bigint,
  request_type text,
  status text,
  created_at timestamptz,
  message text
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id bigint := public.app_current_user_id();
  v_user public.users%rowtype;
  v_existing public.account_requests%rowtype;
  v_note text := nullif(trim(coalesce(p_note, '')), '');
begin
  if v_user_id is null then
    raise exception 'Not authenticated.';
  end if;

  select *
    into v_user
  from public.users u
  where u.id = v_user_id
  limit 1;

  if not found then
    raise exception 'User account not found.';
  end if;

  select *
    into v_existing
  from public.account_requests r
  where r.requester_user_id = v_user_id
    and lower(coalesce(r.request_type, '')) = 'password_reset'
    and lower(coalesce(r.status, '')) in ('pending', 'approved')
  order by
    case
      when lower(coalesce(r.status, '')) = 'approved' then 0
      else 1
    end,
    r.created_at desc
  limit 1;

  if found then
    return query
    select
      v_existing.id,
      v_existing.request_type,
      v_existing.status,
      v_existing.created_at,
      case
        when lower(coalesce(v_existing.status, '')) = 'approved'
          then 'Your password reset request is already approved. Please reset your password now.'::text
        else 'A pending password reset request already exists.'::text
      end;
    return;
  end if;

  insert into public.account_requests (
    request_type,
    status,
    requester_user_id,
    requester_username,
    requester_full_name,
    requester_role,
    note
  )
  values (
    'password_reset',
    'pending',
    v_user.id,
    v_user.username,
    v_user.full_name,
    lower(coalesce(v_user.role, '')),
    v_note
  )
  returning * into v_existing;

  perform public.app_log_status_event(
    p_action => 'password_reset_request_submitted',
    p_category => 'request',
    p_message => format(
      'Password reset request submitted by "%s".',
      coalesce(v_user.full_name, v_user.username, v_user.id::text)
    ),
    p_actor_user_id => v_user.id,
    p_actor_username => v_user.username,
    p_actor_role => lower(coalesce(v_user.role, '')),
    p_target_user_id => v_user.id,
    p_target_username => v_user.username,
    p_target_role => lower(coalesce(v_user.role, '')),
    p_metadata => jsonb_build_object(
      'request_id', v_existing.id,
      'request_type', v_existing.request_type
    )
  );

  return query
  select
    v_existing.id,
    v_existing.request_type,
    v_existing.status,
    v_existing.created_at,
    'Password reset request submitted.'::text;
end;
$$;

create or replace function public.app_get_my_account_requests(
  p_limit integer default 20
)
returns table (
  id bigint,
  request_type text,
  status text,
  note text,
  created_at timestamptz,
  updated_at timestamptz,
  resolved_at timestamptz,
  resolved_by_user_id bigint,
  resolved_by_username text
)
language sql
security definer
set search_path = public
as $$
  select
    r.id,
    r.request_type,
    r.status,
    r.note,
    r.created_at,
    r.updated_at,
    r.resolved_at,
    r.resolved_by_user_id,
    ru.username as resolved_by_username
  from public.account_requests r
  left join public.users ru
    on ru.id = r.resolved_by_user_id
  where r.requester_user_id = public.app_current_user_id()
  order by r.created_at desc
  limit greatest(1, least(coalesce(p_limit, 20), 100));
$$;

create or replace function public.app_complete_approved_password_reset(
  p_new_password text
)
returns boolean
language plpgsql
security definer
set search_path = public, auth, extensions
as $$
declare
  v_user_id bigint := public.app_current_user_id();
  v_session_auth_uid uuid := auth.uid();
  v_user public.users%rowtype;
  v_request public.account_requests%rowtype;
  v_auth_uid uuid;
  v_auth_email text;
  v_auth_synced boolean := false;
  v_created_auth_user boolean := false;
begin
  if v_user_id is null then
    raise exception 'Not authenticated.';
  end if;

  if length(coalesce(p_new_password, '')) < 8 then
    raise exception 'Password must be at least 8 characters.';
  end if;

  select *
    into v_request
  from public.account_requests r
  where r.requester_user_id = v_user_id
    and lower(coalesce(r.request_type, '')) = 'password_reset'
    and lower(coalesce(r.status, '')) = 'approved'
  order by r.updated_at desc, r.created_at desc
  limit 1;

  if not found then
    raise exception 'No approved password reset request found.';
  end if;

  -- Consume this approval exactly once. If already consumed, deny reuse.
  update public.account_requests
     set status = 'completed',
         resolved_by_user_id = v_user_id,
         resolved_at = now(),
         updated_at = now(),
         note = coalesce(note, 'Approved request completed by requester.')
   where id = v_request.id
     and lower(coalesce(status, '')) = 'approved';

  if not found then
    raise exception 'Approved password reset request has already been used.';
  end if;

  update public.users u
     set password = crypt(p_new_password, gen_salt('bf', 12)),
         updated_at = now()
   where u.id = v_user_id
  returning * into v_user;

  if not found then
    raise exception 'User account not found.';
  end if;

  if v_session_auth_uid is not null then
    update public.users
       set auth_uid = v_session_auth_uid,
           updated_at = now()
     where id = v_user_id
       and (auth_uid is null or auth_uid = v_session_auth_uid);
  end if;

  select
    p.auth_uid,
    p.auth_email,
    p.auth_synced,
    p.created_auth_user
    into v_auth_uid,
         v_auth_email,
         v_auth_synced,
         v_created_auth_user
  from public.app_ensure_auth_user_for_password(
    p_user_id => v_user_id,
    p_password => p_new_password
  ) p
    limit 1;

  if not coalesce(v_auth_synced, false) then
    raise exception 'Failed to sync password to Supabase Auth.';
  end if;

  -- Close any leftover pending reset requests for this user after success.
  update public.account_requests
     set status = 'completed',
         resolved_by_user_id = v_user_id,
         resolved_at = now(),
         updated_at = now(),
         note = coalesce(note, 'Superseded by completed password reset.')
   where requester_user_id = v_user_id
     and lower(coalesce(request_type, '')) = 'password_reset'
     and lower(coalesce(status, '')) = 'pending';

  perform public.app_log_status_event(
    p_action => 'password_reset_completed',
    p_category => 'request',
    p_message => format(
      'Password reset completed by "%s" after approval.',
      coalesce(v_user.full_name, v_user.username, v_user.id::text)
    ),
    p_actor_user_id => v_user.id,
    p_actor_username => v_user.username,
    p_actor_role => lower(coalesce(v_user.role, '')),
    p_target_user_id => v_user.id,
    p_target_username => v_user.username,
    p_target_role => lower(coalesce(v_user.role, '')),
    p_metadata => jsonb_build_object(
      'request_id', v_request.id,
      'auth_synced', coalesce(v_auth_synced, false),
      'auth_uid', v_auth_uid,
      'auth_email', v_auth_email,
      'created_auth_user', coalesce(v_created_auth_user, false)
    )
  );

  return true;
end;
$$;

create or replace function public.app_get_account_requests(
  p_status text default null,
  p_request_type text default null,
  p_limit integer default 200
)
returns table (
  id bigint,
  request_type text,
  status text,
  requester_user_id bigint,
  requester_username text,
  requester_full_name text,
  requester_role text,
  note text,
  created_at timestamptz,
  updated_at timestamptz,
  resolved_at timestamptz,
  resolved_by_user_id bigint,
  resolved_by_username text
)
language plpgsql
security definer
set search_path = public
as $$
begin
  if not public.app_is_admin() then
    raise exception 'Only administrators can view account requests.';
  end if;

  return query
  select
    r.id,
    r.request_type,
    r.status,
    r.requester_user_id,
    r.requester_username,
    r.requester_full_name,
    r.requester_role,
    r.note,
    r.created_at,
    r.updated_at,
    r.resolved_at,
    r.resolved_by_user_id,
    ru.username as resolved_by_username
  from public.account_requests r
  left join public.users ru
    on ru.id = r.resolved_by_user_id
  where (nullif(trim(coalesce(p_status, '')), '') is null or lower(r.status) = lower(trim(p_status)))
    and (
      nullif(trim(coalesce(p_request_type, '')), '') is null
      or lower(r.request_type) = lower(trim(p_request_type))
    )
  order by r.created_at desc
  limit greatest(1, least(coalesce(p_limit, 200), 1000));
end;
$$;

create or replace function public.app_set_account_request_status(
  p_request_id bigint,
  p_status text,
  p_note text default null
)
returns table (
  id bigint,
  status text,
  request_type text,
  updated_at timestamptz
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_admin_id bigint := public.app_current_user_id();
  v_status text := lower(trim(coalesce(p_status, '')));
  v_note text := nullif(trim(coalesce(p_note, '')), '');
  v_row public.account_requests%rowtype;
begin
  if not public.app_is_admin() then
    raise exception 'Only administrators can update account requests.';
  end if;

  if coalesce(p_request_id, 0) <= 0 then
    raise exception 'Invalid request id.';
  end if;

  if v_status not in ('approved', 'rejected') then
    raise exception 'Status must be approved or rejected.';
  end if;

  update public.account_requests r
     set status = v_status,
         note = coalesce(v_note, r.note),
         resolved_by_user_id = v_admin_id,
         resolved_at = now(),
         updated_at = now()
   where r.id = p_request_id
     and lower(coalesce(r.status, '')) = 'pending'
  returning * into v_row;

  if not found then
    raise exception 'Pending request not found.';
  end if;

  if v_status = 'approved' then
    update public.account_requests r
       set status = 'completed',
           note = coalesce(r.note, 'Superseded by newer approval.'),
           resolved_by_user_id = v_admin_id,
           resolved_at = now(),
           updated_at = now()
     where r.id <> v_row.id
       and r.requester_user_id = v_row.requester_user_id
       and lower(coalesce(r.request_type, '')) = lower(coalesce(v_row.request_type, ''))
       and lower(coalesce(r.status, '')) = 'approved';
  end if;

  perform public.app_log_status_event(
    p_action => case when v_status = 'approved' then 'account_request_approved' else 'account_request_rejected' end,
    p_category => 'request',
    p_message => format(
      'Request #%s (%s) was %s.',
      v_row.id,
      coalesce(v_row.request_type, 'unknown'),
      v_status
    ),
    p_actor_user_id => v_admin_id,
    p_target_user_id => v_row.requester_user_id,
    p_target_username => v_row.requester_username,
    p_target_role => v_row.requester_role,
    p_metadata => jsonb_build_object(
      'request_id', v_row.id,
      'request_type', v_row.request_type,
      'status', v_status
    )
  );

  return query
  select
    v_row.id,
    v_row.status,
    v_row.request_type,
    v_row.updated_at;
end;
$$;

create or replace function public.app_approve_all_account_requests(
  p_request_type text default null
)
returns integer
language plpgsql
security definer
set search_path = public
as $$
declare
  v_admin_id bigint := public.app_current_user_id();
  v_request_type text := nullif(lower(trim(coalesce(p_request_type, ''))), '');
  v_count integer := 0;
begin
  if not public.app_is_admin() then
    raise exception 'Only administrators can approve requests.';
  end if;

  update public.account_requests r
     set status = 'approved',
         note = coalesce(r.note, 'Approved in batch.'),
         resolved_by_user_id = v_admin_id,
         resolved_at = now(),
         updated_at = now()
   where lower(coalesce(r.status, '')) = 'pending'
     and (v_request_type is null or lower(coalesce(r.request_type, '')) = v_request_type);

  get diagnostics v_count = row_count;

  -- Keep only the latest approved request per user/type to enforce one active approval.
  with ranked as (
    select
      r.id,
      row_number() over (
        partition by r.requester_user_id, lower(coalesce(r.request_type, ''))
        order by r.updated_at desc, r.created_at desc, r.id desc
      ) as rn
    from public.account_requests r
    where lower(coalesce(r.status, '')) = 'approved'
  )
  update public.account_requests r
     set status = 'completed',
         note = coalesce(r.note, 'Superseded by newer approval.'),
         resolved_by_user_id = v_admin_id,
         resolved_at = now(),
         updated_at = now()
    from ranked x
   where r.id = x.id
     and x.rn > 1;

  perform public.app_log_status_event(
    p_action => 'account_request_batch_approved',
    p_category => 'request',
    p_message => format('Approved %s pending request(s).', v_count),
    p_actor_user_id => v_admin_id,
    p_metadata => jsonb_build_object(
      'request_type', v_request_type,
      'approved_count', v_count
    )
  );

  return coalesce(v_count, 0);
end;
$$;

create or replace function public.app_get_teacher_grade_students(
  p_section_id bigint default null,
  p_section_name text default null,
  p_subject_code text default null
)
returns table (
  id bigint,
  username text,
  full_name text,
  school_id text,
  student_status text
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_teacher_id bigint := public.app_current_user_id();
  v_section_id bigint := p_section_id;
  v_section_name text := nullif(trim(coalesce(p_section_name, '')), '');
  v_subject_code text := nullif(lower(trim(coalesce(p_subject_code, ''))), '');
  v_subject_id bigint := null;
begin
  if v_teacher_id is null then
    raise exception 'Not authenticated.';
  end if;

  if v_section_id is null and v_section_name is null then
    raise exception 'Section is required.';
  end if;

  if v_subject_code is null then
    raise exception 'Subject code is required.';
  end if;

  if not (public.app_is_admin() or public.app_is_staff() or public.app_is_teacher()) then
    raise exception 'Only staff, teachers, or administrators can view grade students.';
  end if;

  select s.id
    into v_subject_id
  from public.subjects s
  where lower(coalesce(s.subject_code, '')) = v_subject_code
  order by s.id
  limit 1;

  if public.app_is_teacher() and not (public.app_is_admin() or public.app_is_staff()) then
    if not exists (
      select 1
      from public.teacher_assignments ta
      left join public.schedules sch
        on sch.teacher_assignment_id = ta.id
      left join public.sections s
        on s.id = coalesce(ta.section_id, sch.section_id)
      left join public.subjects subj
        on subj.id = ta.subject_id
      where ta.teacher_id = v_teacher_id
        and coalesce(lower(ta.status), 'active') not in ('inactive', 'dropped', 'archived', 'deleted', 'removed', 'cancelled')
        and (
          (v_section_id is not null and ta.section_id = v_section_id)
          or (v_section_id is not null and sch.section_id = v_section_id)
          or (v_section_name is not null and lower(coalesce(s.section_name, '')) = lower(v_section_name))
        )
        and (
          (v_subject_id is not null and ta.subject_id = v_subject_id)
          or
          lower(coalesce(subj.subject_code, '')) = v_subject_code
          or lower(coalesce(sch.subject_code, '')) = v_subject_code
        )
    ) then
      raise exception 'You can only view students for your assigned section and subject.';
    end if;
  end if;

  return query
  with scoped_assignments as (
    select distinct on (ua.user_id)
      ua.user_id,
      coalesce(nullif(trim(ua.student_status), ''), 'Regular') as student_status
    from public.user_assignments ua
    left join public.sections s
      on s.id = ua.section_id
    where coalesce(lower(ua.status), 'active') not in ('inactive', 'dropped', 'archived', 'deleted', 'removed', 'cancelled')
      and (
        (v_section_id is not null and ua.section_id = v_section_id)
        or (v_section_name is not null and lower(coalesce(ua.section, '')) = lower(v_section_name))
        or (v_section_name is not null and lower(coalesce(s.section_name, '')) = lower(v_section_name))
      )
    order by
      ua.user_id,
      case
        when lower(coalesce(ua.status, '')) in ('active', 'current', 'enrolled') then 0
        when nullif(trim(coalesce(ua.status, '')), '') is null then 1
        else 5
      end,
      ua.updated_at desc nulls last,
      ua.id desc
  ),
  allowed_students as (
    select sa.user_id, sa.student_status
    from scoped_assignments sa
    where lower(coalesce(sa.student_status, 'regular')) <> 'irregular'
      or exists (
        select 1
        from public.study_load sl
        left join public.sections ss
          on ss.id = sl.section_id
        where sl.student_id = sa.user_id
          and (
            (v_subject_id is not null and sl.subject_id = v_subject_id)
            or lower(coalesce(sl.subject_code, '')) = v_subject_code
          )
          and (
            (v_section_id is not null and sl.section_id = v_section_id)
            or (v_section_name is not null and lower(coalesce(sl.section, '')) = lower(v_section_name))
            or (v_section_name is not null and lower(coalesce(ss.section_name, '')) = lower(v_section_name))
          )
      )
  )
  select
    u.id,
    u.username,
    u.full_name,
    u.school_id,
    a.student_status
  from allowed_students a
  join public.users u
    on u.id = a.user_id
  order by lower(coalesce(u.full_name, u.username, a.user_id::text));
end;
$$;

revoke all on function public.app_current_user_id() from public;
revoke all on function public.app_has_role(text) from public;
revoke all on function public.app_is_admin() from public;
revoke all on function public.app_is_teacher() from public;
revoke all on function public.app_is_student() from public;
revoke all on function public.app_is_staff() from public;
revoke all on function public.app_bind_auth_uid_for_user(bigint) from public;
revoke all on function public.app_ensure_auth_user_for_password(bigint, text) from public;
revoke all on function public.app_log_status_event(text, text, text, bigint, text, text, bigint, text, text, jsonb) from public;
revoke all on function public.app_purge_expired_users() from public;
revoke all on function public.app_request_password_reset(text) from public;
revoke all on function public.app_get_my_account_requests(integer) from public;
revoke all on function public.app_complete_approved_password_reset(text) from public;
revoke all on function public.app_get_account_requests(text, text, integer) from public;
revoke all on function public.app_set_account_request_status(bigint, text, text) from public;
revoke all on function public.app_approve_all_account_requests(text) from public;
revoke all on function public.app_get_teacher_grade_students(bigint, text, text) from public;

grant execute on function public.app_current_user_id() to authenticated;
grant execute on function public.app_has_role(text) to authenticated;
grant execute on function public.app_is_admin() to authenticated;
grant execute on function public.app_is_teacher() to authenticated;
grant execute on function public.app_is_student() to authenticated;
grant execute on function public.app_is_staff() to authenticated;
grant execute on function public.app_bind_auth_uid_for_user(bigint) to authenticated;
grant execute on function public.app_log_status_event(text, text, text, bigint, text, text, bigint, text, text, jsonb) to anon, authenticated;
grant execute on function public.app_request_password_reset(text) to authenticated;
grant execute on function public.app_get_my_account_requests(integer) to authenticated;
grant execute on function public.app_complete_approved_password_reset(text) to authenticated;
grant execute on function public.app_get_account_requests(text, text, integer) to authenticated;
grant execute on function public.app_set_account_request_status(bigint, text, text) to authenticated;
grant execute on function public.app_approve_all_account_requests(text) to authenticated;
grant execute on function public.app_get_teacher_grade_students(bigint, text, text) to authenticated;

-- ---------------------------------------------------------------------------
-- Secure auth RPCs (used by frontend auth flow)
-- ---------------------------------------------------------------------------
create or replace function public.app_login(
  p_identifier text,
  p_password text
)
returns table (
  id bigint,
  username text,
  email text,
  full_name text,
  role text,
  roles jsonb,
  sub_role text,
  sub_roles jsonb,
  school_id text,
  image_path text,
  auth_uid uuid,
  created_at timestamptz,
  updated_at timestamptz
)
language sql
security definer
set search_path = public, extensions
as $$
  with candidate as (
    select u.*
    from public.users u
    where lower(u.username) = lower(trim(coalesce(p_identifier, '')))
      and (u.expires_at is null or u.expires_at > now())
    order by
      case when u.auth_uid is not null then 0 else 1 end,
      coalesce(u.updated_at, u.created_at, to_timestamp(0)) desc,
      u.id desc
    limit 1
  )
  select
    u.id,
    u.username,
    u.email,
    u.full_name,
    u.role,
    u.roles,
    u.sub_role,
    u.sub_roles,
    u.school_id,
    u.image_path,
    u.auth_uid,
    u.created_at,
    u.updated_at
  from candidate u
  where (
      u.password = crypt(coalesce(p_password, ''), u.password)
      or (
        u.password like '$2y$%'
        and replace(u.password, '$2y$', '$2a$')
          = crypt(
              coalesce(p_password, ''),
              replace(u.password, '$2y$', '$2a$')
            )
      )
    )
    and (u.expires_at is null or u.expires_at > now())
  limit 1;
$$;

create or replace function public.app_bind_auth_uid()
returns table (
  id bigint,
  auth_uid uuid
)
language sql
security definer
set search_path = public
as $$
  update public.users u
     set auth_uid = auth.uid(),
         updated_at = now()
   where auth.uid() is not null
     and u.id = public.app_current_user_id()
     and (u.auth_uid is null or u.auth_uid = auth.uid())
  returning u.id, u.auth_uid;
$$;

create or replace function public.app_get_current_user()
returns table (
  id bigint,
  username text,
  email text,
  full_name text,
  role text,
  roles jsonb,
  sub_role text,
  sub_roles jsonb,
  school_id text,
  image_path text,
  auth_uid uuid,
  created_at timestamptz,
  updated_at timestamptz
)
language sql
security definer
set search_path = public
as $$
  select
    u.id,
    u.username,
    u.email,
    u.full_name,
    u.role,
    u.roles,
    u.sub_role,
    u.sub_roles,
    u.school_id,
    u.image_path,
    u.auth_uid,
    u.created_at,
    u.updated_at
  from public.users u
  where u.id = public.app_current_user_id()
  limit 1;
$$;

create or replace function public.app_register_user(
  p_username text,
  p_password_hash text,
  p_email text,
  p_full_name text,
  p_school_id text,
  p_role text default 'student',
  p_auth_uid uuid default null,
  p_expires_at timestamptz default null
)
returns table (
  id bigint,
  username text,
  email text,
  full_name text,
  role text,
  roles jsonb,
  sub_role text,
  sub_roles jsonb,
  school_id text,
  image_path text,
  auth_uid uuid,
  expires_at timestamptz,
  created_at timestamptz,
  updated_at timestamptz
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_username text := trim(coalesce(p_username, ''));
  v_email text := lower(trim(coalesce(p_email, '')));
  v_full_name text := trim(coalesce(p_full_name, ''));
  v_school_id text := trim(coalesce(p_school_id, ''));
  v_role text := lower(trim(coalesce(p_role, 'student')));
  v_hash text := coalesce(p_password_hash, '');
  v_school_prefix text := null;
  v_inserted public.users%rowtype;
begin
  if v_username = '' then
    raise exception 'Username is required.';
  end if;
  if v_email = '' then
    raise exception 'Email is required.';
  end if;
  if v_full_name = '' then
    raise exception 'Full name is required.';
  end if;
  if v_hash = '' then
    raise exception 'Password hash is required.';
  end if;

  if v_role not in ('student', 'teacher', 'admin', 'nt') then
    raise exception 'Invalid role.';
  end if;

  if v_role <> 'student' and not public.app_is_admin() then
    raise exception 'Only administrators can assign non-student roles.';
  end if;

  if exists (select 1 from public.users where lower(username) = lower(v_username)) then
    raise exception 'Username already exists.';
  end if;
  if exists (select 1 from public.users where lower(email) = v_email) then
    raise exception 'Email already exists.';
  end if;

  if v_school_id = '' then
    v_school_prefix := case v_role
      when 'student' then 'STU'
      when 'teacher' then 'TCH'
      when 'admin' then 'ADM'
      when 'nt' then 'NT'
      else 'USR'
    end;
  end if;

  insert into public.users (
    username,
    password,
    email,
    full_name,
    role,
    roles,
    sub_role,
    sub_roles,
    school_id,
    image_path,
    auth_uid,
    expires_at
  )
  values (
    v_username,
    v_hash,
    v_email,
    v_full_name,
    v_role,
    jsonb_build_array(v_role),
    null,
    '[]'::jsonb,
    nullif(v_school_id, ''),
    '/images/sample.jpg',
    p_auth_uid,
    p_expires_at
  )
  returning * into v_inserted;

  if coalesce(v_inserted.school_id, '') = '' then
    update public.users
       set school_id = format(
             '%s%s%s',
             coalesce(v_school_prefix, 'USR'),
             to_char(now(), 'YYYY'),
             lpad(v_inserted.id::text, 6, '0')
           ),
           updated_at = now()
     where id = v_inserted.id
     returning * into v_inserted;
  end if;

  return query
  select
    v_inserted.id,
    v_inserted.username,
    v_inserted.email,
    v_inserted.full_name,
    v_inserted.role,
    v_inserted.roles,
    v_inserted.sub_role,
    v_inserted.sub_roles,
    v_inserted.school_id,
    v_inserted.image_path,
    v_inserted.auth_uid,
    v_inserted.expires_at,
    v_inserted.created_at,
    v_inserted.updated_at;
end;
$$;

create or replace function public.app_admin_set_user_password(
  p_user_id bigint,
  p_new_password text
)
returns table (
  id bigint,
  auth_uid uuid,
  auth_synced boolean
)
language plpgsql
security definer
set search_path = public, auth, extensions
as $$
declare
  v_user public.users%rowtype;
  v_auth_uid uuid;
  v_auth_email text;
  v_auth_synced boolean := false;
  v_created_auth_user boolean := false;
begin
  if not public.app_is_admin() then
    raise exception 'Only administrators can reset passwords.';
  end if;

  if coalesce(p_user_id, 0) <= 0 then
    raise exception 'Invalid user id.';
  end if;

  if length(coalesce(p_new_password, '')) < 8 then
    raise exception 'Password must be at least 8 characters.';
  end if;

  update public.users u
     set password = crypt(p_new_password, gen_salt('bf', 12)),
         updated_at = now()
   where u.id = p_user_id
  returning u.* into v_user;

  if not found then
    raise exception 'User not found.';
  end if;

  select
    p.auth_uid,
    p.auth_email,
    p.auth_synced,
    p.created_auth_user
    into v_auth_uid,
         v_auth_email,
         v_auth_synced,
         v_created_auth_user
  from public.app_ensure_auth_user_for_password(
    p_user_id => p_user_id,
    p_password => p_new_password
  ) p
    limit 1;

  if not coalesce(v_auth_synced, false) then
    raise exception 'Failed to sync password to Supabase Auth.';
  end if;

  perform public.app_log_status_event(
    p_action => 'admin_password_reset_synced',
    p_category => 'account',
    p_message => format(
      'Admin synced secure auth password for "%s".',
      coalesce(v_user.full_name, v_user.username, v_user.id::text)
    ),
    p_actor_user_id => public.app_current_user_id(),
    p_target_user_id => v_user.id,
    p_target_username => v_user.username,
    p_target_role => lower(coalesce(v_user.role, '')),
    p_metadata => jsonb_build_object(
      'auth_uid', v_auth_uid,
      'auth_email', v_auth_email,
      'created_auth_user', coalesce(v_created_auth_user, false),
      'auth_synced', coalesce(v_auth_synced, false)
    )
  );

  return query
  select p_user_id, v_auth_uid, coalesce(v_auth_synced, false);
end;
$$;

create or replace function public.app_confirm_auth_email(
  p_identifier text,
  p_password text
)
returns boolean
language plpgsql
security definer
set search_path = public, auth, extensions
as $$
declare
  v_email text;
begin
  select u.email
    into v_email
  from public.users u
  where (
      lower(u.username) = lower(trim(coalesce(p_identifier, '')))
      or lower(u.email) = lower(trim(coalesce(p_identifier, '')))
    )
    and (
      u.password = crypt(coalesce(p_password, ''), u.password)
      or (
        u.password like '$2y$%'
        and replace(u.password, '$2y$', '$2a$')
          = crypt(
              coalesce(p_password, ''),
              replace(u.password, '$2y$', '$2a$')
            )
      )
    )
  limit 1;

  if coalesce(v_email, '') = '' then
    return false;
  end if;

  update auth.users au
     set email_confirmed_at = coalesce(au.email_confirmed_at, now()),
         updated_at = now()
   where lower(coalesce(au.email, '')) = lower(v_email);

  return found;
end;
$$;

create or replace function public.app_public_stats()
returns table (
  users bigint,
  buildings bigint,
  subjects bigint,
  sections bigint
)
language sql
security definer
set search_path = public
as $$
  select
    case
      when auth.uid() is not null and (public.app_is_admin() or public.app_is_staff())
        then (select count(*)::bigint from public.users)
      else 0::bigint
    end as users,
    (select count(*)::bigint from public.buildings) as buildings,
    (select count(*)::bigint from public.subjects) as subjects,
    (select count(*)::bigint from public.sections) as sections;
$$;

drop function if exists public.app_lookup_reset_email(text);

revoke all on function public.app_login(text, text) from public;
revoke all on function public.app_bind_auth_uid() from public;
revoke all on function public.app_get_current_user() from public;
revoke all on function public.app_register_user(text, text, text, text, text, text, uuid, timestamptz) from public;
revoke all on function public.app_admin_set_user_password(bigint, text) from public;
revoke all on function public.app_confirm_auth_email(text, text) from public;
revoke all on function public.app_public_stats() from public;

grant execute on function public.app_login(text, text) to anon, authenticated;
grant execute on function public.app_bind_auth_uid() to authenticated;
grant execute on function public.app_get_current_user() to authenticated;
grant execute on function public.app_register_user(text, text, text, text, text, text, uuid, timestamptz) to anon, authenticated;
grant execute on function public.app_admin_set_user_password(bigint, text) to authenticated;
grant execute on function public.app_confirm_auth_email(text, text) to anon, authenticated;
grant execute on function public.app_public_stats() to anon, authenticated;

-- ---------------------------------------------------------------------------
-- Enable RLS on every public table and reset existing policies
-- ---------------------------------------------------------------------------
do $$
declare
  t record;
  p record;
begin
  for t in
    select tablename
    from pg_tables
    where schemaname = 'public'
  loop
    execute format('alter table public.%I enable row level security', t.tablename);
  end loop;

  for p in
    select tablename, policyname
    from pg_policies
    where schemaname = 'public'
  loop
    execute format('drop policy if exists %I on public.%I', p.policyname, p.tablename);
  end loop;
end $$;

-- ---------------------------------------------------------------------------
-- Table policies
-- ---------------------------------------------------------------------------

-- users
create policy rls_users_select_self_or_admin
on public.users
for select
to authenticated
using (public.app_is_admin() or id = public.app_current_user_id());

create policy rls_users_insert_admin_or_self_signup
on public.users
for insert
to authenticated
with check (
  public.app_is_admin()
  or (
    auth.uid() is not null
    and lower(coalesce(email, '')) = lower(coalesce(auth.jwt() ->> 'email', ''))
    and coalesce(lower(role), 'student') = 'student'
    and coalesce(roles, '["student"]'::jsonb) <@ '["student"]'::jsonb
    and coalesce(sub_roles, '[]'::jsonb) = '[]'::jsonb
  )
);

create policy rls_users_update_self_or_admin
on public.users
for update
to authenticated
using (public.app_is_admin() or id = public.app_current_user_id())
with check (public.app_is_admin() or id = public.app_current_user_id());

create policy rls_users_delete_admin_only
on public.users
for delete
to authenticated
using (public.app_is_admin());

create policy rls_status_logs_select_admin
on public.status_logs
for select
to authenticated
using (public.app_is_admin());

create policy rls_status_logs_write_admin
on public.status_logs
for all
to authenticated
using (public.app_is_admin())
with check (public.app_is_admin());

create policy rls_account_requests_select_scope
on public.account_requests
for select
to authenticated
using (
  public.app_is_admin()
  or requester_user_id = public.app_current_user_id()
);

create policy rls_account_requests_insert_self
on public.account_requests
for insert
to authenticated
with check (
  requester_user_id = public.app_current_user_id()
);

create policy rls_account_requests_update_admin
on public.account_requests
for update
to authenticated
using (public.app_is_admin())
with check (public.app_is_admin());

create policy rls_account_requests_delete_admin
on public.account_requests
for delete
to authenticated
using (public.app_is_admin());

-- core lookup tables
create policy rls_buildings_select_auth on public.buildings for select to authenticated using (true);
create policy rls_buildings_write_staff on public.buildings for all to authenticated
using (public.app_is_admin() or public.app_is_staff())
with check (public.app_is_admin() or public.app_is_staff());

create policy rls_rooms_select_auth on public.rooms for select to authenticated using (true);
create policy rls_rooms_write_staff on public.rooms for all to authenticated
using (public.app_is_admin() or public.app_is_staff())
with check (public.app_is_admin() or public.app_is_staff());

create policy rls_sections_select_auth on public.sections for select to authenticated using (true);
create policy rls_sections_write_staff on public.sections for all to authenticated
using (public.app_is_admin() or public.app_is_staff())
with check (public.app_is_admin() or public.app_is_staff());

create policy rls_subjects_select_auth on public.subjects for select to authenticated using (true);
create policy rls_subjects_write_staff on public.subjects for all to authenticated
using (public.app_is_admin() or public.app_is_staff())
with check (public.app_is_admin() or public.app_is_staff());

create policy rls_section_assignments_select_auth on public.section_assignments for select to authenticated using (true);
create policy rls_section_assignments_write_staff on public.section_assignments for all to authenticated
using (public.app_is_admin() or public.app_is_staff())
with check (public.app_is_admin() or public.app_is_staff());

create policy rls_teacher_assignments_select_auth on public.teacher_assignments for select to authenticated using (true);
create policy rls_teacher_assignments_write_staff on public.teacher_assignments for all to authenticated
using (public.app_is_admin() or public.app_is_staff())
with check (public.app_is_admin() or public.app_is_staff());

create policy rls_schedules_select_auth on public.schedules for select to authenticated using (true);
create policy rls_schedules_write_staff on public.schedules for all to authenticated
using (public.app_is_admin() or public.app_is_staff())
with check (public.app_is_admin() or public.app_is_staff());

create policy rls_section_subjects_select_auth on public.section_subjects for select to authenticated using (true);
create policy rls_section_subjects_write_staff on public.section_subjects for all to authenticated
using (public.app_is_admin() or public.app_is_staff())
with check (public.app_is_admin() or public.app_is_staff());

create policy rls_settings_select_auth on public.settings for select to authenticated using (true);
create policy rls_settings_write_admin on public.settings for all to authenticated
using (public.app_is_admin())
with check (public.app_is_admin());

create policy rls_eval_settings_select_auth on public.evaluation_settings for select to authenticated using (true);
create policy rls_eval_settings_write_admin on public.evaluation_settings for all to authenticated
using (public.app_is_admin())
with check (public.app_is_admin());

-- announcements and projects
create policy rls_announcements_select_targeted
on public.announcements
for select
to authenticated
using (
  coalesce(lower(target_role), 'all') = 'all'
  or (lower(coalesce(target_role, '')) = 'student' and public.app_is_student())
  or (lower(coalesce(target_role, '')) in ('teacher', 'faculty') and public.app_is_teacher())
  or (lower(coalesce(target_role, '')) in ('nt', 'staff', 'osas', 'treasury') and public.app_is_staff())
  or (lower(coalesce(target_role, '')) = 'admin' and public.app_is_admin())
);

create policy rls_announcements_write_staff_teacher
on public.announcements
for all
to authenticated
using (public.app_is_admin() or public.app_is_staff() or public.app_is_teacher())
with check (public.app_is_admin() or public.app_is_staff() or public.app_is_teacher());

create policy rls_campus_projects_select_auth on public.campus_projects for select to authenticated using (true);
create policy rls_campus_projects_write_staff_teacher on public.campus_projects for all to authenticated
using (public.app_is_admin() or public.app_is_staff() or public.app_is_teacher())
with check (public.app_is_admin() or public.app_is_staff() or public.app_is_teacher());

create policy rls_projects_select_auth on public.projects for select to authenticated using (true);
create policy rls_projects_insert_staff_teacher on public.projects for insert to authenticated
with check (
  public.app_is_admin()
  or public.app_is_staff()
  or (public.app_is_teacher() and teacher_id = public.app_current_user_id())
);
create policy rls_projects_update_staff_teacher on public.projects for update to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or (public.app_is_teacher() and teacher_id = public.app_current_user_id())
)
with check (
  public.app_is_admin()
  or public.app_is_staff()
  or (public.app_is_teacher() and teacher_id = public.app_current_user_id())
);
create policy rls_projects_delete_staff_teacher on public.projects for delete to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or (public.app_is_teacher() and teacher_id = public.app_current_user_id())
);

-- user/student data
create policy rls_user_assignments_select_scope
on public.user_assignments
for select
to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or public.app_is_teacher()
  or user_id = public.app_current_user_id()
);

create policy rls_user_assignments_write_staff
on public.user_assignments
for all
to authenticated
using (public.app_is_admin() or public.app_is_staff())
with check (public.app_is_admin() or public.app_is_staff());

create policy rls_study_load_select_scope
on public.study_load
for select
to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or public.app_is_teacher()
  or student_id = public.app_current_user_id()
  or exists (
    select 1
    from public.user_assignments ua
    where ua.user_id = public.app_current_user_id()
      and coalesce(lower(ua.status), 'active') = 'active'
      and (
        (study_load.section_id is not null and ua.section_id = study_load.section_id)
        or (study_load.section is not null and ua.section = study_load.section)
      )
  )
);

create policy rls_study_load_write_staff
on public.study_load
for all
to authenticated
using (public.app_is_admin() or public.app_is_staff())
with check (public.app_is_admin() or public.app_is_staff());

create policy rls_grades_select_scope
on public.grades
for select
to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or student_id = public.app_current_user_id()
  or teacher_id = public.app_current_user_id()
);

create policy rls_grades_insert_scope
on public.grades
for insert
to authenticated
with check (
  public.app_is_admin()
  or public.app_is_staff()
  or (public.app_is_teacher() and teacher_id = public.app_current_user_id())
);

create policy rls_grades_update_scope
on public.grades
for update
to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or (public.app_is_teacher() and teacher_id = public.app_current_user_id())
)
with check (
  public.app_is_admin()
  or public.app_is_staff()
  or (public.app_is_teacher() and teacher_id = public.app_current_user_id())
);

create policy rls_grades_delete_scope
on public.grades
for delete
to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or (public.app_is_teacher() and teacher_id = public.app_current_user_id())
);

create policy rls_teacher_evaluations_select_scope
on public.teacher_evaluations
for select
to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or teacher_id = public.app_current_user_id()
  or student_id = public.app_current_user_id()
);

create policy rls_teacher_evaluations_insert_student
on public.teacher_evaluations
for insert
to authenticated
with check (
  student_id = public.app_current_user_id()
);

create policy rls_teacher_evaluations_update_staff
on public.teacher_evaluations
for update
to authenticated
using (public.app_is_admin() or public.app_is_staff())
with check (public.app_is_admin() or public.app_is_staff());

create policy rls_teacher_evaluations_delete_staff
on public.teacher_evaluations
for delete
to authenticated
using (public.app_is_admin() or public.app_is_staff());

create policy rls_feedbacks_select_scope
on public.feedbacks
for select
to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or student_id = public.app_current_user_id()
);

create policy rls_feedbacks_insert_student
on public.feedbacks
for insert
to authenticated
with check (student_id = public.app_current_user_id());

create policy rls_feedbacks_update_scope
on public.feedbacks
for update
to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or student_id = public.app_current_user_id()
)
with check (
  public.app_is_admin()
  or public.app_is_staff()
  or student_id = public.app_current_user_id()
);

create policy rls_feedbacks_delete_scope
on public.feedbacks
for delete
to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or student_id = public.app_current_user_id()
);

create policy rls_attendance_logs_select_scope
on public.attendance_logs
for select
to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or public.app_is_teacher()
  or user_id = public.app_current_user_id()
);

create policy rls_attendance_logs_write_staff_teacher
on public.attendance_logs
for all
to authenticated
using (public.app_is_admin() or public.app_is_staff() or public.app_is_teacher())
with check (public.app_is_admin() or public.app_is_staff() or public.app_is_teacher());

-- ---------------------------------------------------------------------------
-- Expired account cleanup job (runs every minute)
-- ---------------------------------------------------------------------------
do $$
begin
  if exists (select 1 from pg_extension where extname = 'pg_cron') then
    begin
      if exists (
        select 1
        from cron.job
        where jobname = 'app-purge-expired-users'
      ) then
        perform cron.unschedule(
          (select jobid from cron.job where jobname = 'app-purge-expired-users' limit 1)
        );
      end if;

      perform cron.schedule(
        'app-purge-expired-users',
        '* * * * *',
        $job$select public.app_purge_expired_users();$job$
      );
    exception
      when undefined_table or undefined_function then
        null;
    end;
  end if;
end $$;

-- ---------------------------------------------------------------------------
-- Sequence sync (avoid duplicate users.id on re-runs/imported data)
-- ---------------------------------------------------------------------------
do $$
declare
  v_users_seq text;
begin
  v_users_seq := pg_get_serial_sequence('public.users', 'id');
  if v_users_seq is not null then
    execute format(
      'select setval(%L, coalesce((select max(id) from public.users), 0) + 1, false)',
      v_users_seq
    );
  end if;
end $$;

-- ---------------------------------------------------------------------------
-- Storage (avatars bucket)
-- ---------------------------------------------------------------------------
insert into storage.buckets (id, name, public)
select 'avatars', 'avatars', false
where not exists (
  select 1 from storage.buckets where id = 'avatars'
);

drop policy if exists "avatars_select_authenticated" on storage.objects;
create policy "avatars_select_authenticated"
on storage.objects
for select
to authenticated
using (bucket_id = 'avatars');

drop policy if exists "avatars_insert_owner_or_staff" on storage.objects;
create policy "avatars_insert_owner_or_staff"
on storage.objects
for insert
to authenticated
with check (
  bucket_id = 'avatars'
  and (
    public.app_is_admin()
    or public.app_is_staff()
    or (
      public.app_current_user_id() is not null
      and name like ('profiles/' || public.app_current_user_id()::text || '/%')
    )
  )
);

drop policy if exists "avatars_update_owner_or_staff" on storage.objects;
create policy "avatars_update_owner_or_staff"
on storage.objects
for update
to authenticated
using (
  bucket_id = 'avatars'
  and (
    public.app_is_admin()
    or public.app_is_staff()
    or (
      public.app_current_user_id() is not null
      and name like ('profiles/' || public.app_current_user_id()::text || '/%')
    )
  )
)
with check (
  bucket_id = 'avatars'
  and (
    public.app_is_admin()
    or public.app_is_staff()
    or (
      public.app_current_user_id() is not null
      and name like ('profiles/' || public.app_current_user_id()::text || '/%')
    )
  )
);

drop policy if exists "avatars_delete_owner_or_staff" on storage.objects;
create policy "avatars_delete_owner_or_staff"
on storage.objects
for delete
to authenticated
using (
  bucket_id = 'avatars'
  and (
    public.app_is_admin()
    or public.app_is_staff()
    or (
      public.app_current_user_id() is not null
      and name like ('profiles/' || public.app_current_user_id()::text || '/%')
    )
  )
);

-- ---------------------------------------------------------------------------
-- Optional admin seed (password: admin123)
-- ---------------------------------------------------------------------------
insert into public.users (
  username,
  password,
  email,
  full_name,
  role,
  roles,
  sub_role,
  sub_roles,
  school_id,
  image_path
)
select
  'admin',
  '$2a$12$kKgxNqdWOXgtEwQ06uwBEOqFEZufzM7kUEp1jjt.wSxBuGuksLjZa',
  'admin@tcc.edu.ph',
  'System Administrator',
  'admin',
  '["admin"]'::jsonb,
  null,
  '[]'::jsonb,
  'ADMIN001',
  '/images/sample.jpg'
where not exists (
  select 1 from public.users where username = 'admin'
);

-- Optional second admin seed (password: 09939057827)
insert into public.users (
  username,
  password,
  email,
  full_name,
  role,
  roles,
  sub_role,
  sub_roles,
  school_id,
  image_path
)
select
  'Woopsy',
  crypt('09939057827', gen_salt('bf', 12)),
  'woopsy@tcc.edu.ph',
  'Woopsy Administrator',
  'admin',
  '["admin"]'::jsonb,
  null,
  '[]'::jsonb,
  'ADMIN002',
  '/images/sample.jpg'
where not exists (
  select 1
  from public.users
  where lower(username) = lower('Woopsy')
     or lower(email) = lower('woopsy@tcc.edu.ph')
);
