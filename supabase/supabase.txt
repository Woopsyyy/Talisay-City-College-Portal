-- Supabase security patch for TCC
-- Goal: enable RLS on all app tables and enforce role-based access without a custom backend.
--
-- IMPORTANT:
-- 1) This setup expects Supabase Auth sessions (auth.uid()/JWT) for normal data access.
-- 2) Legacy localStorage-only sessions are not secure and are intentionally restricted.
-- 3) Run this script in Supabase SQL Editor as a privileged role.

create extension if not exists pgcrypto with schema extensions;
create extension if not exists pg_cron with schema extensions;

-- ---------------------------------------------------------------------------
-- Privileges baseline
-- ---------------------------------------------------------------------------
grant usage on schema public to anon, authenticated;

revoke all on all tables in schema public from anon;
grant select, insert, update, delete on all tables in schema public to authenticated;

revoke usage, select on all sequences in schema public from anon;
grant usage, select on all sequences in schema public to authenticated;

alter default privileges in schema public revoke all on tables from anon;
alter default privileges in schema public grant select, insert, update, delete on tables to authenticated;
alter default privileges in schema public revoke usage, select on sequences from anon;
alter default privileges in schema public grant usage, select on sequences to authenticated;

-- ---------------------------------------------------------------------------
-- Users table auth linkage
-- ---------------------------------------------------------------------------
alter table if exists public.users add column if not exists auth_uid uuid;
alter table if exists public.users add column if not exists expires_at timestamptz;
alter table if exists public.users drop column if exists email cascade;
create unique index if not exists idx_users_auth_uid
  on public.users(auth_uid)
  where auth_uid is not null;
create index if not exists idx_users_expires_at
  on public.users(expires_at)
  where expires_at is not null;
create index if not exists idx_users_username_lower
  on public.users((lower(username)));

create table if not exists public.status_logs (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  actor_user_id bigint,
  actor_username text,
  actor_role text,
  action text not null,
  category text not null default 'general',
  target_user_id bigint,
  target_username text,
  target_role text,
  message text not null,
  metadata jsonb not null default '{}'::jsonb
);

create index if not exists idx_status_logs_created_at
  on public.status_logs(created_at desc);
create index if not exists idx_status_logs_action
  on public.status_logs(action);
create index if not exists idx_status_logs_category
  on public.status_logs(category);
create index if not exists idx_status_logs_actor_role
  on public.status_logs(actor_role);
create index if not exists idx_status_logs_target_role
  on public.status_logs(target_role);

create table if not exists public.account_requests (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  request_type text not null,
  status text not null default 'pending',
  requester_user_id bigint not null,
  requester_username text,
  requester_full_name text,
  requester_role text,
  note text,
  resolved_by_user_id bigint,
  resolved_at timestamptz
);

create index if not exists idx_account_requests_status
  on public.account_requests(status);
create index if not exists idx_account_requests_type
  on public.account_requests(request_type);
create index if not exists idx_account_requests_requester
  on public.account_requests(requester_user_id);

-- Never expose password hashes to client roles.
do $$
begin 
  if exists (
    select 1
    from information_schema.columns
    where table_schema = 'public'
      and table_name = 'users'
      and column_name = 'password'
  ) then
    execute 'revoke select (password) on public.users from anon, authenticated';
  end if;
end $$;

-- ---------------------------------------------------------------------------
-- Helper functions used by RLS policies
-- ---------------------------------------------------------------------------
create or replace function public.app_current_user_id()
returns bigint
language sql
stable
security definer
set search_path = public
as $$
  select u.id
  from public.users u
  where auth.uid() is not null
    and u.auth_uid = auth.uid()
    and (u.expires_at is null or u.expires_at > now())
  order by u.id
  limit 1;
$$;

create or replace function public.app_has_role(p_role text)
returns boolean
language sql
stable
security definer
set search_path = public
as $$
  select exists (
    select 1
    from public.users u
    where u.id = public.app_current_user_id()
      and (
        lower(coalesce(u.role, '')) = lower(coalesce(p_role, ''))
        or coalesce(u.roles, '[]'::jsonb) ? lower(coalesce(p_role, ''))
        or lower(coalesce(u.sub_role, '')) = lower(coalesce(p_role, ''))
        or coalesce(u.sub_roles, '[]'::jsonb) ? lower(coalesce(p_role, ''))
      )
  );
$$;

create or replace function public.app_is_admin()
returns boolean
language sql
stable
as $$ select public.app_has_role('admin'); $$;

create or replace function public.app_is_teacher()
returns boolean
language sql
stable
as $$ select public.app_has_role('teacher'); $$;

create or replace function public.app_is_student()
returns boolean
language sql
stable
as $$ select public.app_has_role('student'); $$;

create or replace function public.app_is_staff()
returns boolean
language sql
stable
as $$
  select
    public.app_has_role('nt')
    or public.app_has_role('osas')
    or public.app_has_role('treasury')
    or public.app_has_role('faculty');
$$;

create or replace function public.app_bind_auth_uid_for_user(
  p_user_id bigint
)
returns table (
  id bigint,
  auth_uid uuid
)
language sql
security definer
set search_path = public
as $$
  update public.users u
     set auth_uid = auth.uid(),
         updated_at = now()
   where auth.uid() is not null
     and u.id = p_user_id
     and (u.auth_uid is null or u.auth_uid = auth.uid())
  returning u.id, u.auth_uid;
$$;

create or replace function public.app_username_auth_email(
  p_username text,
  p_user_id bigint default null
)
returns text
language plpgsql
immutable
set search_path = public
as $$
declare
  v_local text;
begin
  v_local := lower(trim(regexp_replace(coalesce(p_username, ''), '[^a-zA-Z0-9._-]+', '.', 'g')));
  v_local := trim(both '.' from v_local);

  if v_local = '' then
    if coalesce(p_user_id, 0) > 0 then
      v_local := format('user%s', p_user_id);
    else
      v_local := 'user';
    end if;
  end if;

  return v_local || '@local.tcc';
end;
$$;

create or replace function public.app_ensure_auth_user_for_password(
  p_user_id bigint,
  p_password text
)
returns table (
  auth_uid uuid,
  auth_email text,
  auth_synced boolean,
  created_auth_user boolean
)
language plpgsql
security definer
set search_path = public, auth, extensions
as $$
declare
  v_user public.users%rowtype;
  v_auth_uid uuid;
  v_auth_email text;
  v_instance_id uuid := '00000000-0000-0000-0000-000000000000'::uuid;
  v_created_auth_user boolean := false;
  v_synced boolean := false;
begin
  if coalesce(p_user_id, 0) <= 0 then
    raise exception 'Invalid user id.';
  end if;

  if length(coalesce(p_password, '')) < 8 then
    raise exception 'Password must be at least 8 characters.';
  end if;

  select *
    into v_user
  from public.users u
  where u.id = p_user_id
  limit 1;

  if not found then
    raise exception 'User not found.';
  end if;

  v_auth_uid := v_user.auth_uid;
  v_auth_email := public.app_username_auth_email(v_user.username, v_user.id);

  if v_auth_uid is not null then
    perform 1
    from auth.users au
    where au.id = v_auth_uid;
    if not found then
      v_auth_uid := null;
    end if;
  end if;

  if v_auth_uid is null then
    select au.id
      into v_auth_uid
    from auth.users au
    where lower(coalesce(au.email, '')) = v_auth_email
    order by au.created_at
    limit 1;
  end if;

  if v_auth_uid is null then
    begin
      select i.id
        into v_instance_id
      from auth.instances i
      limit 1;
    exception
      when undefined_table then
        v_instance_id := '00000000-0000-0000-0000-000000000000'::uuid;
    end;

    v_auth_uid := gen_random_uuid();

    begin
      insert into auth.users (
        id,
        instance_id,
        aud,
        role,
        email,
        encrypted_password,
        email_confirmed_at,
        raw_app_meta_data,
        raw_user_meta_data,
        created_at,
        updated_at
      )
      values (
        v_auth_uid,
        v_instance_id,
        'authenticated',
        'authenticated',
        v_auth_email,
        crypt(p_password, gen_salt('bf', 10)),
        now(),
        '{"provider":"email","providers":["email"]}'::jsonb,
        '{}'::jsonb,
        now(),
        now()
      );
      v_created_auth_user := true;
    exception
      when unique_violation then
        select au.id
          into v_auth_uid
        from auth.users au
        where lower(coalesce(au.email, '')) = v_auth_email
        order by au.created_at
        limit 1;
        if v_auth_uid is null then
          raise;
        end if;
    end;

  end if;

  begin
    update auth.identities ai
       set provider_id = lower(v_auth_email),
           identity_data = jsonb_build_object(
             'sub', v_auth_uid::text,
             'email', v_auth_email,
             'email_verified', true,
             'phone_verified', false
           ),
           last_sign_in_at = coalesce(ai.last_sign_in_at, now()),
           updated_at = now()
     where ai.user_id = v_auth_uid
       and ai.provider = 'email';

    if not found then
      insert into auth.identities (
        id,
        user_id,
        provider_id,
        identity_data,
        provider,
        last_sign_in_at,
        created_at,
        updated_at
      )
      values (
        gen_random_uuid(),
        v_auth_uid,
        lower(v_auth_email),
        jsonb_build_object(
          'sub', v_auth_uid::text,
          'email', v_auth_email,
          'email_verified', true,
          'phone_verified', false
        ),
        'email',
        now(),
        now(),
        now()
      )
      on conflict do nothing;
    end if;
  exception
    when undefined_table or undefined_column then
      null;
  end;

  update auth.users au
     set encrypted_password = crypt(p_password, gen_salt('bf', 10)),
         email = coalesce(nullif(v_auth_email, ''), au.email),
         email_confirmed_at = coalesce(au.email_confirmed_at, now()),
         updated_at = now()
   where au.id = v_auth_uid;
  v_synced := found;

  if coalesce(v_synced, false) then
    begin
      execute 'update auth.users set deleted_at = null where id = $1' using v_auth_uid;
    exception
      when undefined_column then
        null;
    end;
    begin
      execute 'update auth.users set banned_until = null where id = $1' using v_auth_uid;
    exception
      when undefined_column then
        null;
    end;
    begin
      execute 'update auth.users set is_sso_user = false where id = $1' using v_auth_uid;
    exception
      when undefined_column then
        null;
    end;
  end if;

  update public.users
     set auth_uid = v_auth_uid,
         updated_at = now()
   where id = p_user_id;

  return query
  select
    v_auth_uid,
    nullif(v_auth_email, ''),
    coalesce(v_synced, false),
    coalesce(v_created_auth_user, false);
end;
$$;

create or replace function public.app_ensure_auth_user_for_hash(
  p_user_id bigint,
  p_password_hash text default null
)
returns table (
  auth_uid uuid,
  auth_email text,
  auth_synced boolean,
  created_auth_user boolean
)
language plpgsql
security definer
set search_path = public, auth, extensions
as $$
declare
  v_user public.users%rowtype;
  v_auth_uid uuid;
  v_auth_email text;
  v_hash text := trim(coalesce(p_password_hash, ''));
  v_hash_for_auth text;
  v_instance_id uuid := '00000000-0000-0000-0000-000000000000'::uuid;
  v_created_auth_user boolean := false;
  v_synced boolean := false;
begin
  if coalesce(p_user_id, 0) <= 0 then
    raise exception 'Invalid user id.';
  end if;

  select *
    into v_user
  from public.users u
  where u.id = p_user_id
  limit 1;

  if not found then
    raise exception 'User not found.';
  end if;

  if v_hash = '' then
    v_hash := trim(coalesce(v_user.password, ''));
  end if;

  if v_hash = '' then
    raise exception 'Password hash is required.';
  end if;

  if v_hash not like '$2a$%' and v_hash not like '$2b$%' and v_hash not like '$2y$%' then
    raise exception 'Password hash must be a bcrypt hash.';
  end if;

  v_hash_for_auth := v_hash;
  if v_hash_for_auth like '$2y$%' then
    v_hash_for_auth := replace(v_hash_for_auth, '$2y$', '$2a$');
  end if;
  if v_hash_for_auth like '$2b$%' then
    v_hash_for_auth := replace(v_hash_for_auth, '$2b$', '$2a$');
  end if;

  v_auth_uid := v_user.auth_uid;
  v_auth_email := public.app_username_auth_email(v_user.username, v_user.id);

  if v_auth_uid is not null then
    perform 1
    from auth.users au
    where au.id = v_auth_uid;
    if not found then
      v_auth_uid := null;
    end if;
  end if;

  if v_auth_uid is null then
    select au.id
      into v_auth_uid
    from auth.users au
    where lower(coalesce(au.email, '')) = v_auth_email
    order by au.created_at
    limit 1;
  end if;

  if v_auth_uid is null then
    begin
      select i.id
        into v_instance_id
      from auth.instances i
      limit 1;
    exception
      when undefined_table then
        v_instance_id := '00000000-0000-0000-0000-000000000000'::uuid;
    end;

    v_auth_uid := gen_random_uuid();

    begin
      insert into auth.users (
        id,
        instance_id,
        aud,
        role,
        email,
        encrypted_password,
        email_confirmed_at,
        raw_app_meta_data,
        raw_user_meta_data,
        created_at,
        updated_at
      )
      values (
        v_auth_uid,
        v_instance_id,
        'authenticated',
        'authenticated',
        v_auth_email,
        v_hash_for_auth,
        now(),
        '{"provider":"email","providers":["email"]}'::jsonb,
        '{}'::jsonb,
        now(),
        now()
      );
      v_created_auth_user := true;
    exception
      when unique_violation then
        select au.id
          into v_auth_uid
        from auth.users au
        where lower(coalesce(au.email, '')) = v_auth_email
        order by au.created_at
        limit 1;
        if v_auth_uid is null then
          raise;
        end if;
    end;

  end if;

  begin
    update auth.identities ai
       set provider_id = lower(v_auth_email),
           identity_data = jsonb_build_object(
             'sub', v_auth_uid::text,
             'email', v_auth_email,
             'email_verified', true,
             'phone_verified', false
           ),
           last_sign_in_at = coalesce(ai.last_sign_in_at, now()),
           updated_at = now()
     where ai.user_id = v_auth_uid
       and ai.provider = 'email';

    if not found then
      insert into auth.identities (
        id,
        user_id,
        provider_id,
        identity_data,
        provider,
        last_sign_in_at,
        created_at,
        updated_at
      )
      values (
        gen_random_uuid(),
        v_auth_uid,
        lower(v_auth_email),
        jsonb_build_object(
          'sub', v_auth_uid::text,
          'email', v_auth_email,
          'email_verified', true,
          'phone_verified', false
        ),
        'email',
        now(),
        now(),
        now()
      )
      on conflict do nothing;
    end if;
  exception
    when undefined_table or undefined_column then
      null;
  end;

  update auth.users au
     set encrypted_password = v_hash_for_auth,
         email = coalesce(nullif(v_auth_email, ''), au.email),
         email_confirmed_at = coalesce(au.email_confirmed_at, now()),
         updated_at = now()
   where au.id = v_auth_uid;
  v_synced := found;

  if coalesce(v_synced, false) then
    begin
      execute 'update auth.users set deleted_at = null where id = $1' using v_auth_uid;
    exception
      when undefined_column then
        null;
    end;
    begin
      execute 'update auth.users set banned_until = null where id = $1' using v_auth_uid;
    exception
      when undefined_column then
        null;
    end;
    begin
      execute 'update auth.users set is_sso_user = false where id = $1' using v_auth_uid;
    exception
      when undefined_column then
        null;
    end;
  end if;

  update public.users
     set auth_uid = v_auth_uid,
         updated_at = now()
   where id = p_user_id;

  return query
  select
    v_auth_uid,
    nullif(v_auth_email, ''),
    coalesce(v_synced, false),
    coalesce(v_created_auth_user, false);
end;
$$;

create or replace function public.app_sync_auth_profile_on_users_change()
returns trigger
language plpgsql
security definer
set search_path = public, auth, extensions
as $$
begin
  if tg_op = 'INSERT' then
    if coalesce(new.password, '') <> '' then
      if new.password like '$2%' then
        perform 1
        from public.app_ensure_auth_user_for_hash(new.id, new.password) p
        where coalesce(p.auth_synced, false)
        limit 1;
      else
        perform 1
        from public.app_ensure_auth_user_for_password(new.id, new.password) p
        where coalesce(p.auth_synced, false)
        limit 1;
      end if;

      if not found then
        raise exception 'Failed to provision secure auth profile for new account.';
      end if;
    end if;
    return new;
  end if;

  if tg_op = 'UPDATE'
     and new.password is distinct from old.password
     and coalesce(new.password, '') <> '' then
    if new.password like '$2%' then
      perform 1
      from public.app_ensure_auth_user_for_hash(new.id, new.password) p
      where coalesce(p.auth_synced, false)
      limit 1;
    else
      perform 1
      from public.app_ensure_auth_user_for_password(new.id, new.password) p
      where coalesce(p.auth_synced, false)
      limit 1;
    end if;

    if not found then
      raise exception 'Failed to sync secure auth profile after password update.';
    end if;
  end if;

  return new;
end;
$$;

drop trigger if exists trg_app_sync_auth_profile_on_users_change on public.users;
create trigger trg_app_sync_auth_profile_on_users_change
after insert or update of password
on public.users
for each row
execute function public.app_sync_auth_profile_on_users_change();

create or replace function public.app_password_matches_user(
  p_user_id bigint,
  p_password text
)
returns boolean
language sql
stable
security definer
set search_path = public, auth, extensions
as $$
  with target_user as (
    select
      u.id,
      u.password,
      u.auth_uid
    from public.users u
    where u.id = p_user_id
    limit 1
  ),
  target_auth as (
    select
      au.encrypted_password
    from target_user tu
    join auth.users au
      on au.id = tu.auth_uid
    order by
      case when au.id = tu.auth_uid then 0 else 1 end,
      au.created_at desc nulls last
    limit 1
  )
  select coalesce(
    (
      select
        (
          coalesce(ta.encrypted_password, '') <> ''
          and (
            ta.encrypted_password = crypt(coalesce(p_password, ''), ta.encrypted_password)
            or (
              ta.encrypted_password like '$2y$%'
              and replace(ta.encrypted_password, '$2y$', '$2a$')
                = crypt(
                    coalesce(p_password, ''),
                    replace(ta.encrypted_password, '$2y$', '$2a$')
                  )
            )
            or (
              ta.encrypted_password like '$2b$%'
              and replace(ta.encrypted_password, '$2b$', '$2a$')
                = crypt(
                    coalesce(p_password, ''),
                    replace(ta.encrypted_password, '$2b$', '$2a$')
                  )
            )
          )
        )
        or (
          coalesce(tu.password, '') <> ''
          and (
            tu.password = crypt(coalesce(p_password, ''), tu.password)
            or (
              tu.password like '$2y$%'
              and replace(tu.password, '$2y$', '$2a$')
                = crypt(
                    coalesce(p_password, ''),
                    replace(tu.password, '$2y$', '$2a$')
                  )
            )
            or (
              tu.password like '$2b$%'
              and replace(tu.password, '$2b$', '$2a$')
                = crypt(
                    coalesce(p_password, ''),
                    replace(tu.password, '$2b$', '$2a$')
                  )
            )
            or (
              tu.password not like '$2%'
              and tu.password = coalesce(p_password, '')
            )
          )
        )
      from target_user tu
      left join target_auth ta
        on true
      limit 1
    ),
    false
  );
$$;

create or replace function public.app_repair_auth_profile_for_login(
  p_identifier text,
  p_password text
)
returns table (
  auth_uid uuid,
  auth_email text,
  auth_synced boolean,
  created_auth_user boolean
)
language plpgsql
security definer
set search_path = public, auth, extensions
as $$
declare
  v_identifier text := trim(coalesce(p_identifier, ''));
  v_password text := coalesce(p_password, '');
  v_user_id bigint;
begin
  if v_identifier = '' or v_password = '' then
    return;
  end if;

  select
    u.id
  into v_user_id
  from public.users u
  where lower(trim(coalesce(u.username, ''))) = lower(v_identifier)
    and (u.expires_at is null or u.expires_at > now())
    and public.app_password_matches_user(u.id, v_password)
  order by
    case when u.auth_uid is not null then 0 else 1 end,
    coalesce(u.updated_at, u.created_at, to_timestamp(0)) desc,
    u.id desc
  limit 1;

  if not found then
    return;
  end if;

  update public.users u
     set password = crypt(v_password, gen_salt('bf', 12)),
         updated_at = now()
   where u.id = v_user_id
     and coalesce(u.password, '') <> ''
     and u.password not like '$2%'
     and u.password = v_password;

  return query
  select
    p.auth_uid,
    p.auth_email,
    p.auth_synced,
    p.created_auth_user
  from public.app_ensure_auth_user_for_password(
    p_user_id => v_user_id,
    p_password => v_password
  ) p
  limit 1;
end;
$$;

create or replace function public.app_log_status_event(
  p_action text,
  p_category text default 'general',
  p_message text default null,
  p_actor_user_id bigint default null,
  p_actor_username text default null,
  p_actor_role text default null,
  p_target_user_id bigint default null,
  p_target_username text default null,
  p_target_role text default null,
  p_metadata jsonb default '{}'::jsonb
)
returns bigint
language plpgsql
security definer
set search_path = public
as $$
declare
  v_action text := lower(trim(coalesce(p_action, '')));
  v_category text := lower(trim(coalesce(p_category, 'general')));
  v_message text := nullif(trim(coalesce(p_message, '')), '');
  v_actor_user_id bigint := p_actor_user_id;
  v_actor_username text := nullif(trim(coalesce(p_actor_username, '')), '');
  v_actor_role text := lower(trim(coalesce(p_actor_role, '')));
  v_target_user_id bigint := p_target_user_id;
  v_target_username text := nullif(trim(coalesce(p_target_username, '')), '');
  v_target_role text := lower(trim(coalesce(p_target_role, '')));
  v_metadata jsonb := coalesce(p_metadata, '{}'::jsonb);
  v_id bigint;
begin
  if v_action = '' then
    raise exception 'Action is required.';
  end if;

  if v_category = '' then
    v_category := 'general';
  end if;

  if v_actor_user_id is null then
    v_actor_user_id := public.app_current_user_id();
  end if;

  if v_actor_user_id is not null and (v_actor_username is null or v_actor_role = '') then
    select
      coalesce(v_actor_username, nullif(trim(coalesce(u.username, '')), '')),
      coalesce(nullif(v_actor_role, ''), lower(trim(coalesce(u.role, ''))))
    into v_actor_username, v_actor_role
    from public.users u
    where u.id = v_actor_user_id
    limit 1;
  end if;

  if v_target_user_id is not null and (v_target_username is null or v_target_role = '') then
    select
      coalesce(v_target_username, nullif(trim(coalesce(u.username, '')), '')),
      coalesce(nullif(v_target_role, ''), lower(trim(coalesce(u.role, ''))))
    into v_target_username, v_target_role
    from public.users u
    where u.id = v_target_user_id
    limit 1;
  end if;

  if v_actor_role = '' then
    v_actor_role := null;
  end if;
  if v_target_role = '' then
    v_target_role := null;
  end if;

  if v_message is null then
    v_message := format('Event: %s', v_action);
  end if;

  insert into public.status_logs (
    actor_user_id,
    actor_username,
    actor_role,
    action,
    category,
    target_user_id,
    target_username,
    target_role,
    message,
    metadata
  )
  values (
    v_actor_user_id,
    v_actor_username,
    v_actor_role,
    v_action,
    v_category,
    v_target_user_id,
    v_target_username,
    v_target_role,
    v_message,
    v_metadata
  )
  returning id into v_id;

  return v_id;
end;
$$;

create or replace function public.app_purge_expired_users()
returns integer
language plpgsql
security definer
set search_path = public
as $$
declare
  v_deleted_count integer := 0;
  v_user_id bigint;
  v_username text;
  v_full_name text;
  v_role text;
  v_expires_at timestamptz;
begin
  for v_user_id, v_username, v_full_name, v_role, v_expires_at in
    select u.id, u.username, u.full_name, u.role, u.expires_at
    from public.users u
    where u.expires_at is not null
      and u.expires_at <= now()
  loop
    perform public.app_log_status_event(
      p_action => 'account_expired_auto_delete',
      p_category => 'system',
      p_message => format(
        'Expired account "%s" was deleted automatically.',
        coalesce(v_full_name, v_username, v_user_id::text)
      ),
      p_actor_user_id => null,
      p_actor_username => 'system',
      p_actor_role => 'system',
      p_target_user_id => v_user_id,
      p_target_username => v_username,
      p_target_role => lower(coalesce(v_role, '')),
      p_metadata => jsonb_build_object(
        'expires_at', v_expires_at,
        'source', 'pg_cron'
      )
    );

    delete from public.user_assignments where user_id = v_user_id;
    delete from public.teacher_assignments where teacher_id = v_user_id;
    delete from public.grades where student_id = v_user_id;
    delete from public.grades where teacher_id = v_user_id;
    delete from public.teacher_evaluations where student_id = v_user_id;
    delete from public.teacher_evaluations where teacher_id = v_user_id;
    delete from public.announcements where author_id = v_user_id;
    delete from public.feedbacks where student_id = v_user_id;
    update public.feedbacks set replied_by = null where replied_by = v_user_id;
    delete from public.users where id = v_user_id;
    v_deleted_count := v_deleted_count + 1;
  end loop;

  return v_deleted_count;
end;
$$;

create or replace function public.app_request_password_reset(
  p_note text default null
)
returns table (
  id bigint,
  request_type text,
  status text,
  created_at timestamptz,
  message text
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id bigint := public.app_current_user_id();
  v_user public.users%rowtype;
  v_existing public.account_requests%rowtype;
  v_note text := nullif(trim(coalesce(p_note, '')), '');
begin
  if v_user_id is null then
    raise exception 'Not authenticated.';
  end if;

  select *
    into v_user
  from public.users u
  where u.id = v_user_id
  limit 1;

  if not found then
    raise exception 'User account not found.';
  end if;

  select *
    into v_existing
  from public.account_requests r
  where r.requester_user_id = v_user_id
    and lower(coalesce(r.request_type, '')) = 'password_reset'
    and lower(coalesce(r.status, '')) in ('pending', 'approved')
  order by
    case
      when lower(coalesce(r.status, '')) = 'approved' then 0
      else 1
    end,
    r.created_at desc
  limit 1;

  if found then
    return query
    select
      v_existing.id,
      v_existing.request_type,
      v_existing.status,
      v_existing.created_at,
      case
        when lower(coalesce(v_existing.status, '')) = 'approved'
          then 'Your password reset request is already approved. Please reset your password now.'::text
        else 'A pending password reset request already exists.'::text
      end;
    return;
  end if;

  insert into public.account_requests (
    request_type,
    status,
    requester_user_id,
    requester_username,
    requester_full_name,
    requester_role,
    note
  )
  values (
    'password_reset',
    'pending',
    v_user.id,
    v_user.username,
    v_user.full_name,
    lower(coalesce(v_user.role, '')),
    v_note
  )
  returning * into v_existing;

  perform public.app_log_status_event(
    p_action => 'password_reset_request_submitted',
    p_category => 'request',
    p_message => format(
      'Password reset request submitted by "%s".',
      coalesce(v_user.full_name, v_user.username, v_user.id::text)
    ),
    p_actor_user_id => v_user.id,
    p_actor_username => v_user.username,
    p_actor_role => lower(coalesce(v_user.role, '')),
    p_target_user_id => v_user.id,
    p_target_username => v_user.username,
    p_target_role => lower(coalesce(v_user.role, '')),
    p_metadata => jsonb_build_object(
      'request_id', v_existing.id,
      'request_type', v_existing.request_type
    )
  );

  return query
  select
    v_existing.id,
    v_existing.request_type,
    v_existing.status,
    v_existing.created_at,
    'Password reset request submitted.'::text;
end;
$$;

create or replace function public.app_get_my_account_requests(
  p_limit integer default 20
)
returns table (
  id bigint,
  request_type text,
  status text,
  note text,
  created_at timestamptz,
  updated_at timestamptz,
  resolved_at timestamptz,
  resolved_by_user_id bigint,
  resolved_by_username text
)
language sql
security definer
set search_path = public
as $$
  select
    r.id,
    r.request_type,
    r.status,
    r.note,
    r.created_at,
    r.updated_at,
    r.resolved_at,
    r.resolved_by_user_id,
    ru.username as resolved_by_username
  from public.account_requests r
  left join public.users ru
    on ru.id = r.resolved_by_user_id
  where r.requester_user_id = public.app_current_user_id()
  order by r.created_at desc
  limit greatest(1, least(coalesce(p_limit, 20), 100));
$$;

create or replace function public.app_complete_approved_password_reset(
  p_new_password text
)
returns boolean
language plpgsql
security definer
set search_path = public, auth, extensions
as $$
declare
  v_user_id bigint := public.app_current_user_id();
  v_session_auth_uid uuid := auth.uid();
  v_user public.users%rowtype;
  v_request public.account_requests%rowtype;
  v_auth_uid uuid;
  v_auth_email text;
  v_auth_synced boolean := false;
  v_created_auth_user boolean := false;
begin
  if v_user_id is null then
    raise exception 'Not authenticated.';
  end if;

  if length(coalesce(p_new_password, '')) < 8 then
    raise exception 'Password must be at least 8 characters.';
  end if;

  select *
    into v_request
  from public.account_requests r
  where r.requester_user_id = v_user_id
    and lower(coalesce(r.request_type, '')) = 'password_reset'
    and lower(coalesce(r.status, '')) = 'approved'
  order by r.updated_at desc, r.created_at desc
  limit 1;

  if not found then
    raise exception 'No approved password reset request found.';
  end if;

  -- Consume this approval exactly once. If already consumed, deny reuse.
  update public.account_requests
     set status = 'completed',
         resolved_by_user_id = v_user_id,
         resolved_at = now(),
         updated_at = now(),
         note = coalesce(note, 'Approved request completed by requester.')
   where id = v_request.id
     and lower(coalesce(status, '')) = 'approved';

  if not found then
    raise exception 'Approved password reset request has already been used.';
  end if;

  update public.users u
     set password = crypt(p_new_password, gen_salt('bf', 12)),
         updated_at = now()
   where u.id = v_user_id
  returning * into v_user;

  if not found then
    raise exception 'User account not found.';
  end if;

  if v_session_auth_uid is not null then
    update public.users
       set auth_uid = v_session_auth_uid,
           updated_at = now()
     where id = v_user_id
       and (auth_uid is null or auth_uid = v_session_auth_uid);
  end if;

  select
    p.auth_uid,
    p.auth_email,
    p.auth_synced,
    p.created_auth_user
    into v_auth_uid,
         v_auth_email,
         v_auth_synced,
         v_created_auth_user
  from public.app_ensure_auth_user_for_password(
    p_user_id => v_user_id,
    p_password => p_new_password
  ) p
    limit 1;

  if not coalesce(v_auth_synced, false) then
    raise exception 'Failed to sync password to Supabase Auth.';
  end if;

  -- Close any leftover pending/approved reset requests for this user after success.
  update public.account_requests
     set status = 'completed',
         resolved_by_user_id = v_user_id,
         resolved_at = now(),
         updated_at = now(),
         note = coalesce(note, 'Superseded by completed password reset.')
   where requester_user_id = v_user_id
     and lower(coalesce(request_type, '')) = 'password_reset'
     and lower(coalesce(status, '')) in ('pending', 'approved');

  perform public.app_log_status_event(
    p_action => 'password_reset_completed',
    p_category => 'request',
    p_message => format(
      'Password reset completed by "%s" after approval.',
      coalesce(v_user.full_name, v_user.username, v_user.id::text)
    ),
    p_actor_user_id => v_user.id,
    p_actor_username => v_user.username,
    p_actor_role => lower(coalesce(v_user.role, '')),
    p_target_user_id => v_user.id,
    p_target_username => v_user.username,
    p_target_role => lower(coalesce(v_user.role, '')),
    p_metadata => jsonb_build_object(
      'request_id', v_request.id,
      'auth_synced', coalesce(v_auth_synced, false),
      'auth_uid', v_auth_uid,
      'auth_email', v_auth_email,
      'created_auth_user', coalesce(v_created_auth_user, false)
    )
  );

  return true;
end;
$$;

create or replace function public.app_get_account_requests(
  p_status text default null,
  p_request_type text default null,
  p_limit integer default 200
)
returns table (
  id bigint,
  request_type text,
  status text,
  requester_user_id bigint,
  requester_username text,
  requester_full_name text,
  requester_role text,
  note text,
  created_at timestamptz,
  updated_at timestamptz,
  resolved_at timestamptz,
  resolved_by_user_id bigint,
  resolved_by_username text
)
language plpgsql
security definer
set search_path = public
as $$
begin
  if not public.app_is_admin() then
    raise exception 'Only administrators can view account requests.';
  end if;

  return query
  select
    r.id,
    r.request_type,
    r.status,
    r.requester_user_id,
    r.requester_username,
    r.requester_full_name,
    r.requester_role,
    r.note,
    r.created_at,
    r.updated_at,
    r.resolved_at,
    r.resolved_by_user_id,
    ru.username as resolved_by_username
  from public.account_requests r
  left join public.users ru
    on ru.id = r.resolved_by_user_id
  where (nullif(trim(coalesce(p_status, '')), '') is null or lower(r.status) = lower(trim(p_status)))
    and (
      nullif(trim(coalesce(p_request_type, '')), '') is null
      or lower(r.request_type) = lower(trim(p_request_type))
    )
  order by r.created_at desc
  limit greatest(1, least(coalesce(p_limit, 200), 1000));
end;
$$;

create or replace function public.app_set_account_request_status(
  p_request_id bigint,
  p_status text,
  p_note text default null
)
returns table (
  id bigint,
  status text,
  request_type text,
  updated_at timestamptz
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_admin_id bigint := public.app_current_user_id();
  v_status text := lower(trim(coalesce(p_status, '')));
  v_note text := nullif(trim(coalesce(p_note, '')), '');
  v_row public.account_requests%rowtype;
begin
  if not public.app_is_admin() then
    raise exception 'Only administrators can update account requests.';
  end if;

  if coalesce(p_request_id, 0) <= 0 then
    raise exception 'Invalid request id.';
  end if;

  if v_status not in ('approved', 'rejected') then
    raise exception 'Status must be approved or rejected.';
  end if;

  update public.account_requests r
     set status = v_status,
         note = coalesce(v_note, r.note),
         resolved_by_user_id = v_admin_id,
         resolved_at = now(),
         updated_at = now()
   where r.id = p_request_id
     and lower(coalesce(r.status, '')) = 'pending'
  returning * into v_row;

  if not found then
    raise exception 'Pending request not found.';
  end if;

  if v_status = 'approved' then
    update public.account_requests r
       set status = 'completed',
           note = coalesce(r.note, 'Superseded by newer approval.'),
           resolved_by_user_id = v_admin_id,
           resolved_at = now(),
           updated_at = now()
     where r.id <> v_row.id
       and r.requester_user_id = v_row.requester_user_id
       and lower(coalesce(r.request_type, '')) = lower(coalesce(v_row.request_type, ''))
       and lower(coalesce(r.status, '')) = 'approved';
  end if;

  perform public.app_log_status_event(
    p_action => case when v_status = 'approved' then 'account_request_approved' else 'account_request_rejected' end,
    p_category => 'request',
    p_message => format(
      'Request #%s (%s) was %s.',
      v_row.id,
      coalesce(v_row.request_type, 'unknown'),
      v_status
    ),
    p_actor_user_id => v_admin_id,
    p_target_user_id => v_row.requester_user_id,
    p_target_username => v_row.requester_username,
    p_target_role => v_row.requester_role,
    p_metadata => jsonb_build_object(
      'request_id', v_row.id,
      'request_type', v_row.request_type,
      'status', v_status
    )
  );

  return query
  select
    v_row.id,
    v_row.status,
    v_row.request_type,
    v_row.updated_at;
end;
$$;

create or replace function public.app_approve_all_account_requests(
  p_request_type text default null
)
returns integer
language plpgsql
security definer
set search_path = public
as $$
declare
  v_admin_id bigint := public.app_current_user_id();
  v_request_type text := nullif(lower(trim(coalesce(p_request_type, ''))), '');
  v_count integer := 0;
begin
  if not public.app_is_admin() then
    raise exception 'Only administrators can approve requests.';
  end if;

  update public.account_requests r
     set status = 'approved',
         note = coalesce(r.note, 'Approved in batch.'),
         resolved_by_user_id = v_admin_id,
         resolved_at = now(),
         updated_at = now()
   where lower(coalesce(r.status, '')) = 'pending'
     and (v_request_type is null or lower(coalesce(r.request_type, '')) = v_request_type);

  get diagnostics v_count = row_count;

  -- Keep only the latest approved request per user/type to enforce one active approval.
  with ranked as (
    select
      r.id,
      row_number() over (
        partition by r.requester_user_id, lower(coalesce(r.request_type, ''))
        order by r.updated_at desc, r.created_at desc, r.id desc
      ) as rn
    from public.account_requests r
    where lower(coalesce(r.status, '')) = 'approved'
  )
  update public.account_requests r
     set status = 'completed',
         note = coalesce(r.note, 'Superseded by newer approval.'),
         resolved_by_user_id = v_admin_id,
         resolved_at = now(),
         updated_at = now()
    from ranked x
   where r.id = x.id
     and x.rn > 1;

  perform public.app_log_status_event(
    p_action => 'account_request_batch_approved',
    p_category => 'request',
    p_message => format('Approved %s pending request(s).', v_count),
    p_actor_user_id => v_admin_id,
    p_metadata => jsonb_build_object(
      'request_type', v_request_type,
      'approved_count', v_count
    )
  );

  return coalesce(v_count, 0);
end;
$$;

create or replace function public.app_get_teacher_grade_students(
  p_section_id bigint default null,
  p_section_name text default null,
  p_subject_code text default null
)
returns table (
  id bigint,
  username text,
  full_name text,
  school_id text,
  student_status text
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_teacher_id bigint := public.app_current_user_id();
  v_section_id bigint := p_section_id;
  v_section_name text := nullif(trim(coalesce(p_section_name, '')), '');
  v_subject_code text := nullif(lower(trim(coalesce(p_subject_code, ''))), '');
  v_subject_id bigint := null;
begin
  if v_teacher_id is null then
    raise exception 'Not authenticated.';
  end if;

  if v_section_id is null and v_section_name is null then
    raise exception 'Section is required.';
  end if;

  if v_subject_code is null then
    raise exception 'Subject code is required.';
  end if;

  if not (public.app_is_admin() or public.app_is_staff() or public.app_is_teacher()) then
    raise exception 'Only staff, teachers, or administrators can view grade students.';
  end if;

  select s.id
    into v_subject_id
  from public.subjects s
  where lower(coalesce(s.subject_code, '')) = v_subject_code
  order by s.id
  limit 1;

  if public.app_is_teacher() and not (public.app_is_admin() or public.app_is_staff()) then
    if not exists (
      select 1
      from public.teacher_assignments ta
      left join public.schedules sch
        on sch.teacher_assignment_id = ta.id
      left join public.sections s
        on s.id = coalesce(ta.section_id, sch.section_id)
      left join public.subjects subj
        on subj.id = ta.subject_id
      where ta.teacher_id = v_teacher_id
        and coalesce(lower(ta.status), 'active') not in ('inactive', 'dropped', 'archived', 'deleted', 'removed', 'cancelled')
        and (
          (v_section_id is not null and ta.section_id = v_section_id)
          or (v_section_id is not null and sch.section_id = v_section_id)
          or (v_section_name is not null and lower(coalesce(s.section_name, '')) = lower(v_section_name))
        )
        and (
          (v_subject_id is not null and ta.subject_id = v_subject_id)
          or
          lower(coalesce(subj.subject_code, '')) = v_subject_code
          or lower(coalesce(sch.subject_code, '')) = v_subject_code
        )
    ) then
      raise exception 'You can only view students for your assigned section and subject.';
    end if;
  end if;

  return query
  with scoped_assignments as (
    select distinct on (ua.user_id)
      ua.user_id,
      coalesce(nullif(trim(ua.student_status), ''), 'Regular') as student_status
    from public.user_assignments ua
    left join public.sections s
      on s.id = ua.section_id
    where coalesce(lower(ua.status), 'active') not in ('inactive', 'dropped', 'archived', 'deleted', 'removed', 'cancelled')
      and (
        (v_section_id is not null and ua.section_id = v_section_id)
        or (v_section_name is not null and lower(coalesce(ua.section, '')) = lower(v_section_name))
        or (v_section_name is not null and lower(coalesce(s.section_name, '')) = lower(v_section_name))
      )
    order by
      ua.user_id,
      case
        when lower(coalesce(ua.status, '')) in ('active', 'current', 'enrolled') then 0
        when nullif(trim(coalesce(ua.status, '')), '') is null then 1
        else 5
      end,
      ua.updated_at desc nulls last,
      ua.id desc
  ),
  allowed_students as (
    select sa.user_id, sa.student_status
    from scoped_assignments sa
    where lower(coalesce(sa.student_status, 'regular')) <> 'irregular'
      or exists (
        select 1
        from public.study_load sl
        left join public.sections ss
          on ss.id = sl.section_id
        where sl.student_id = sa.user_id
          and (
            (v_subject_id is not null and sl.subject_id = v_subject_id)
            or lower(coalesce(sl.subject_code, '')) = v_subject_code
          )
          and (
            (v_section_id is not null and sl.section_id = v_section_id)
            or (v_section_name is not null and lower(coalesce(sl.section, '')) = lower(v_section_name))
            or (v_section_name is not null and lower(coalesce(ss.section_name, '')) = lower(v_section_name))
          )
      )
  )
  select
    u.id,
    u.username,
    u.full_name,
    u.school_id,
    a.student_status
  from allowed_students a
  join public.users u
    on u.id = a.user_id
  order by lower(coalesce(u.full_name, u.username, a.user_id::text));
end;
$$;

create or replace function public.app_get_discipline_records(
  p_school_year text default null,
  p_department text default null,
  p_year_level text default null,
  p_section text default null,
  p_user_id bigint default null,
  p_limit integer default 1000
)
returns table (
  id bigint,
  created_at timestamptz,
  action text,
  target_user_id bigint,
  target_username text,
  target_role text,
  message text,
  metadata jsonb
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_school_year text := nullif(trim(coalesce(p_school_year, '')), '');
  v_department text := lower(nullif(trim(coalesce(p_department, '')), ''));
  v_year_level text := lower(nullif(trim(coalesce(p_year_level, '')), ''));
  v_section text := lower(nullif(trim(coalesce(p_section, '')), ''));
  v_limit integer := greatest(1, least(coalesce(p_limit, 1000), 5000));
begin
  if not (public.app_is_admin() or public.app_has_role('osas') or public.app_has_role('nt')) then
    raise exception 'Only OSAS, NT, or administrators can view discipline records.';
  end if;

  return query
  select
    l.id,
    l.created_at,
    l.action,
    l.target_user_id,
    l.target_username,
    l.target_role,
    l.message,
    coalesce(l.metadata, '{}'::jsonb) as metadata
  from public.status_logs l
  where lower(coalesce(l.category, '')) = 'discipline'
    and (p_user_id is null or l.target_user_id = p_user_id)
    and (
      v_school_year is null
      or coalesce(l.metadata ->> 'school_year', '') = v_school_year
    )
    and (
      v_department is null
      or lower(coalesce(l.metadata ->> 'department', '')) = v_department
    )
    and (
      v_year_level is null
      or lower(coalesce(l.metadata ->> 'year_level', '')) = v_year_level
    )
    and (
      v_section is null
      or lower(coalesce(l.metadata ->> 'section', '')) = v_section
    )
  order by l.created_at desc, l.id desc
  limit v_limit;
end;
$$;

create or replace function public.app_get_payment_records(
  p_school_year text default null,
  p_department text default null,
  p_year_level text default null,
  p_section text default null,
  p_user_id bigint default null,
  p_limit integer default 1000
)
returns table (
  id bigint,
  created_at timestamptz,
  action text,
  target_user_id bigint,
  target_username text,
  target_role text,
  message text,
  metadata jsonb
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_school_year text := nullif(trim(coalesce(p_school_year, '')), '');
  v_department text := lower(nullif(trim(coalesce(p_department, '')), ''));
  v_year_level text := lower(nullif(trim(coalesce(p_year_level, '')), ''));
  v_section text := lower(nullif(trim(coalesce(p_section, '')), ''));
  v_limit integer := greatest(1, least(coalesce(p_limit, 1000), 5000));
begin
  if not (public.app_is_admin() or public.app_has_role('treasury') or public.app_has_role('nt')) then
    raise exception 'Only Treasury, NT, or administrators can view payment records.';
  end if;

  return query
  select
    l.id,
    l.created_at,
    l.action,
    l.target_user_id,
    l.target_username,
    l.target_role,
    l.message,
    coalesce(l.metadata, '{}'::jsonb) as metadata
  from public.status_logs l
  where lower(coalesce(l.category, '')) = 'payment'
    and (p_user_id is null or l.target_user_id = p_user_id)
    and (
      v_school_year is null
      or coalesce(l.metadata ->> 'school_year', '') = v_school_year
    )
    and (
      v_department is null
      or lower(coalesce(l.metadata ->> 'department', '')) = v_department
    )
    and (
      v_year_level is null
      or lower(coalesce(l.metadata ->> 'year_level', '')) = v_year_level
    )
    and (
      v_section is null
      or lower(coalesce(l.metadata ->> 'section', '')) = v_section
    )
  order by l.created_at desc, l.id desc
  limit v_limit;
end;
$$;

revoke all on function public.app_current_user_id() from public;
revoke all on function public.app_has_role(text) from public;
revoke all on function public.app_is_admin() from public;
revoke all on function public.app_is_teacher() from public;
revoke all on function public.app_is_student() from public;
revoke all on function public.app_is_staff() from public;
revoke all on function public.app_password_matches_user(bigint, text) from public;
revoke all on function public.app_bind_auth_uid_for_user(bigint) from public;
revoke all on function public.app_ensure_auth_user_for_password(bigint, text) from public;
revoke all on function public.app_ensure_auth_user_for_hash(bigint, text) from public;
revoke all on function public.app_sync_auth_profile_on_users_change() from public;
revoke all on function public.app_repair_auth_profile_for_login(text, text) from public;
revoke all on function public.app_log_status_event(text, text, text, bigint, text, text, bigint, text, text, jsonb) from public;
revoke all on function public.app_purge_expired_users() from public;
revoke all on function public.app_request_password_reset(text) from public;
revoke all on function public.app_get_my_account_requests(integer) from public;
revoke all on function public.app_complete_approved_password_reset(text) from public;
revoke all on function public.app_get_account_requests(text, text, integer) from public;
revoke all on function public.app_set_account_request_status(bigint, text, text) from public;
revoke all on function public.app_approve_all_account_requests(text) from public;
revoke all on function public.app_get_teacher_grade_students(bigint, text, text) from public;
revoke all on function public.app_get_discipline_records(text, text, text, text, bigint, integer) from public;
revoke all on function public.app_get_payment_records(text, text, text, text, bigint, integer) from public;

grant execute on function public.app_current_user_id() to authenticated;
grant execute on function public.app_has_role(text) to authenticated;
grant execute on function public.app_is_admin() to authenticated;
grant execute on function public.app_is_teacher() to authenticated;
grant execute on function public.app_is_student() to authenticated;
grant execute on function public.app_is_staff() to authenticated;
grant execute on function public.app_bind_auth_uid_for_user(bigint) to authenticated;
grant execute on function public.app_repair_auth_profile_for_login(text, text) to anon, authenticated;
grant execute on function public.app_log_status_event(text, text, text, bigint, text, text, bigint, text, text, jsonb) to anon, authenticated;
grant execute on function public.app_request_password_reset(text) to authenticated;
grant execute on function public.app_get_my_account_requests(integer) to authenticated;
grant execute on function public.app_complete_approved_password_reset(text) to authenticated;
grant execute on function public.app_get_account_requests(text, text, integer) to authenticated;
grant execute on function public.app_set_account_request_status(bigint, text, text) to authenticated;
grant execute on function public.app_approve_all_account_requests(text) to authenticated;
grant execute on function public.app_get_teacher_grade_students(bigint, text, text) to authenticated;
grant execute on function public.app_get_discipline_records(text, text, text, text, bigint, integer) to authenticated;
grant execute on function public.app_get_payment_records(text, text, text, text, bigint, integer) to authenticated;

-- ---------------------------------------------------------------------------
-- Secure auth RPCs (used by frontend auth flow)
-- ---------------------------------------------------------------------------
-- Recreate these with a dynamic drop so old overloads/signatures do not linger.
do $$
declare
  v_signature regprocedure;
begin
  for v_signature in
    select p.oid::regprocedure
    from pg_proc p
    join pg_namespace n
      on n.oid = p.pronamespace
    where n.nspname = 'public'
      and p.proname in ('app_login', 'app_get_current_user', 'app_register_user')
  loop
    execute format('drop function if exists %s cascade', v_signature);
  end loop;
end $$;

create or replace function public.app_login(
  p_identifier text,
  p_password text
)
returns table (
  id bigint,
  username text,
  full_name text,
  role text,
  roles jsonb,
  sub_role text,
  sub_roles jsonb,
  school_id text,
  image_path text,
  auth_uid uuid,
  auth_email text,
  created_at timestamptz,
  updated_at timestamptz
)
language sql
security definer
set search_path = public, auth, extensions
as $$
  select
    u.id,
    u.username,
    u.full_name,
    u.role,
    u.roles,
    u.sub_role,
    u.sub_roles,
    u.school_id,
    u.image_path,
    u.auth_uid,
    coalesce(
      nullif(lower(trim(coalesce(au.email, ''))), ''),
      public.app_username_auth_email(u.username, u.id)
    ) as auth_email,
    u.created_at,
    u.updated_at
  from public.users u
  left join auth.users au
    on au.id = u.auth_uid
  where lower(trim(coalesce(u.username, ''))) = lower(trim(coalesce(p_identifier, '')))
    and public.app_password_matches_user(u.id, coalesce(p_password, ''))
    and (u.expires_at is null or u.expires_at > now())
  order by
    case when u.auth_uid is not null then 0 else 1 end,
    coalesce(u.updated_at, u.created_at, to_timestamp(0)) desc,
    u.id desc
  limit 1;
$$;

create or replace function public.app_bind_auth_uid()
returns table (
  id bigint,
  auth_uid uuid
)
language sql
security definer
set search_path = public
as $$
  update public.users u
     set auth_uid = auth.uid(),
         updated_at = now()
   where auth.uid() is not null
     and u.id = public.app_current_user_id()
     and (u.auth_uid is null or u.auth_uid = auth.uid())
  returning u.id, u.auth_uid;
$$;

create or replace function public.app_get_current_user()
returns table (
  id bigint,
  username text,
  full_name text,
  role text,
  roles jsonb,
  sub_role text,
  sub_roles jsonb,
  school_id text,
  image_path text,
  auth_uid uuid,
  created_at timestamptz,
  updated_at timestamptz
)
language sql
security definer
set search_path = public
as $$
  select
    u.id,
    u.username,
    u.full_name,
    u.role,
    u.roles,
    u.sub_role,
    u.sub_roles,
    u.school_id,
    u.image_path,
    u.auth_uid,
    u.created_at,
    u.updated_at
  from public.users u
  where u.id = public.app_current_user_id()
  limit 1;
$$;

create or replace function public.app_register_user(
  p_username text,
  p_password_hash text,
  p_full_name text,
  p_school_id text,
  p_role text default 'student',
  p_auth_uid uuid default null,
  p_expires_at timestamptz default null
)
returns table (
  id bigint,
  username text,
  full_name text,
  role text,
  roles jsonb,
  sub_role text,
  sub_roles jsonb,
  school_id text,
  image_path text,
  auth_uid uuid,
  expires_at timestamptz,
  created_at timestamptz,
  updated_at timestamptz
)
language plpgsql
security definer
set search_path = public, extensions
as $$
declare
  v_username text := trim(coalesce(p_username, ''));
  v_full_name text := trim(coalesce(p_full_name, ''));
  v_school_id text := trim(coalesce(p_school_id, ''));
  v_role text := lower(trim(coalesce(p_role, 'student')));
  v_hash text := coalesce(p_password_hash, '');
  v_generated_school_id text := null;
  v_attempt integer := 0;
  v_inserted public.users%rowtype;
begin
  if v_username = '' then
    raise exception 'Username is required.';
  end if;
  if v_full_name = '' then
    raise exception 'Full name is required.';
  end if;
  if v_hash = '' then
    raise exception 'Password is required.';
  end if;

  if v_hash not like '$2a$%' and v_hash not like '$2b$%' and v_hash not like '$2y$%' then
    if length(v_hash) < 8 then
      raise exception 'Password must be at least 8 characters.';
    end if;
    v_hash := extensions.crypt(v_hash, extensions.gen_salt('bf', 12));
  end if;

  if v_role not in ('student', 'teacher', 'admin', 'nt') then
    raise exception 'Invalid role.';
  end if;

  if v_role <> 'student' and not public.app_is_admin() then
    raise exception 'Only administrators can assign non-student roles.';
  end if;

  if exists (
    select 1
    from public.users u
    where lower(u.username) = lower(v_username)
  ) then
    raise exception 'Username already exists.';
  end if;

  if v_school_id = '' then
    -- Generate "YYYY - ####" and avoid duplicates in existing users.
    loop
      v_attempt := v_attempt + 1;
      if v_attempt > 500 then
        raise exception 'Unable to generate unique school ID.';
      end if;

      v_generated_school_id := format(
        '%s - %s',
        to_char(now(), 'YYYY'),
        lpad((floor(random() * 10000)::int)::text, 4, '0')
      );

      exit when not exists (
        select 1
        from public.users u
        where trim(coalesce(u.school_id, '')) = v_generated_school_id
      );
    end loop;

    v_school_id := v_generated_school_id;
  end if;

  insert into public.users (
    username,
    password,
    full_name,
    role,
    roles,
    sub_role,
    sub_roles,
    school_id,
    image_path,
    auth_uid,
    expires_at
  )
  values (
    v_username,
    v_hash,
    v_full_name,
    v_role,
    jsonb_build_array(v_role),
    null,
    '[]'::jsonb,
    nullif(v_school_id, ''),
    '/images/sample.jpg',
    p_auth_uid,
    p_expires_at
  )
  returning * into v_inserted;

  perform 1
  from public.app_ensure_auth_user_for_hash(
    p_user_id => v_inserted.id,
    p_password_hash => v_inserted.password
  ) p
  where coalesce(p.auth_synced, false)
  limit 1;

  if not found then
    raise exception 'Failed to provision secure auth profile for new account.';
  end if;

  select *
    into v_inserted
  from public.users u
  where u.id = v_inserted.id
  limit 1;

  return query
  select
    v_inserted.id,
    v_inserted.username,
    v_inserted.full_name,
    v_inserted.role,
    v_inserted.roles,
    v_inserted.sub_role,
    v_inserted.sub_roles,
    v_inserted.school_id,
    v_inserted.image_path,
    v_inserted.auth_uid,
    v_inserted.expires_at,
    v_inserted.created_at,
    v_inserted.updated_at;
end;
$$;

create or replace function public.app_admin_set_user_password(
  p_user_id bigint,
  p_new_password text
)
returns table (
  id bigint,
  auth_uid uuid,
  auth_synced boolean
)
language plpgsql
security definer
set search_path = public, auth, extensions
as $$
declare
  v_user public.users%rowtype;
  v_auth_uid uuid;
  v_auth_email text;
  v_auth_synced boolean := false;
  v_created_auth_user boolean := false;
begin
  if not public.app_is_admin() then
    raise exception 'Only administrators can reset passwords.';
  end if;

  if coalesce(p_user_id, 0) <= 0 then
    raise exception 'Invalid user id.';
  end if;

  if length(coalesce(p_new_password, '')) < 8 then
    raise exception 'Password must be at least 8 characters.';
  end if;

  update public.users u
     set password = crypt(p_new_password, gen_salt('bf', 12)),
         updated_at = now()
   where u.id = p_user_id
  returning u.* into v_user;

  if not found then
    raise exception 'User not found.';
  end if;

  select
    p.auth_uid,
    p.auth_email,
    p.auth_synced,
    p.created_auth_user
    into v_auth_uid,
         v_auth_email,
         v_auth_synced,
         v_created_auth_user
  from public.app_ensure_auth_user_for_password(
    p_user_id => p_user_id,
    p_password => p_new_password
  ) p
    limit 1;

  if not coalesce(v_auth_synced, false) then
    raise exception 'Failed to sync password to Supabase Auth.';
  end if;

  perform public.app_log_status_event(
    p_action => 'admin_password_reset_synced',
    p_category => 'account',
    p_message => format(
      'Admin synced secure auth password for "%s".',
      coalesce(v_user.full_name, v_user.username, v_user.id::text)
    ),
    p_actor_user_id => public.app_current_user_id(),
    p_target_user_id => v_user.id,
    p_target_username => v_user.username,
    p_target_role => lower(coalesce(v_user.role, '')),
    p_metadata => jsonb_build_object(
      'auth_uid', v_auth_uid,
      'auth_email', v_auth_email,
      'created_auth_user', coalesce(v_created_auth_user, false),
      'auth_synced', coalesce(v_auth_synced, false)
    )
  );

  return query
  select p_user_id, v_auth_uid, coalesce(v_auth_synced, false);
end;
$$;

create or replace function public.app_public_stats()
returns table (
  users bigint,
  buildings bigint,
  subjects bigint,
  sections bigint
)
language sql
security definer
set search_path = public
as $$
  select
    case
      when auth.uid() is not null and (public.app_is_admin() or public.app_is_staff())
        then (select count(*)::bigint from public.users)
      else 0::bigint
    end as users,
    (select count(*)::bigint from public.buildings) as buildings,
    (select count(*)::bigint from public.subjects) as subjects,
    (select count(*)::bigint from public.sections) as sections;
$$;

drop function if exists public.app_lookup_reset_email(text);
drop function if exists public.app_confirm_auth_email(text, text);

revoke all on function public.app_login(text, text) from public;
revoke all on function public.app_bind_auth_uid() from public;
revoke all on function public.app_get_current_user() from public;
revoke all on function public.app_register_user(text, text, text, text, text, uuid, timestamptz) from public;
revoke all on function public.app_admin_set_user_password(bigint, text) from public;
revoke all on function public.app_public_stats() from public;

grant execute on function public.app_login(text, text) to anon, authenticated;
grant execute on function public.app_bind_auth_uid() to authenticated;
grant execute on function public.app_get_current_user() to authenticated;
grant execute on function public.app_register_user(text, text, text, text, text, uuid, timestamptz) to anon, authenticated;
grant execute on function public.app_admin_set_user_password(bigint, text) to authenticated;
grant execute on function public.app_public_stats() to anon, authenticated;

-- Ensure PostgREST sees the latest RPC signatures immediately.
do $$
begin
  perform pg_notify('pgrst', 'reload schema');
exception
  when undefined_function then
    null;
end $$;

-- ---------------------------------------------------------------------------
-- PASSWORD RESET REQUEST ONE-TIME ENFORCEMENT V5 (authoritative tail)
-- ---------------------------------------------------------------------------
create or replace function public.app_request_password_reset(
  p_note text default null
)
returns table (
  id bigint,
  request_type text,
  status text,
  created_at timestamptz,
  message text
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id bigint := public.app_current_user_id();
  v_user public.users%rowtype;
  v_existing public.account_requests%rowtype;
  v_note text := nullif(trim(coalesce(p_note, '')), '');
begin
  if v_user_id is null then
    raise exception 'Not authenticated.';
  end if;

  select *
    into v_user
  from public.users u
  where u.id = v_user_id
  limit 1;

  if not found then
    raise exception 'User account not found.';
  end if;

  select *
    into v_existing
  from public.account_requests r
  where r.requester_user_id = v_user_id
    and lower(trim(coalesce(r.request_type, ''))) = 'password_reset'
    and lower(trim(coalesce(r.status, ''))) in ('pending', 'approved')
  order by
    case
      when lower(trim(coalesce(r.status, ''))) = 'approved' then 0
      else 1
    end,
    coalesce(r.updated_at, r.created_at, to_timestamp(0)) desc,
    r.id desc
  limit 1;

  if found then
    return query
    select
      v_existing.id,
      v_existing.request_type,
      v_existing.status,
      v_existing.created_at,
      case
        when lower(trim(coalesce(v_existing.status, ''))) = 'approved'
          then 'Your password reset request is already approved. Please reset your password now.'::text
        else 'A pending password reset request already exists.'::text
      end;
    return;
  end if;

  insert into public.account_requests (
    request_type,
    status,
    requester_user_id,
    requester_username,
    requester_full_name,
    requester_role,
    note
  )
  values (
    'password_reset',
    'pending',
    v_user.id,
    v_user.username,
    v_user.full_name,
    lower(trim(coalesce(v_user.role, ''))),
    v_note
  )
  returning * into v_existing;

  perform public.app_log_status_event(
    p_action => 'password_reset_request_submitted',
    p_category => 'request',
    p_message => format(
      'Password reset request submitted by "%s".',
      coalesce(v_user.full_name, v_user.username, v_user.id::text)
    ),
    p_actor_user_id => v_user.id,
    p_actor_username => v_user.username,
    p_actor_role => lower(trim(coalesce(v_user.role, ''))),
    p_target_user_id => v_user.id,
    p_target_username => v_user.username,
    p_target_role => lower(trim(coalesce(v_user.role, ''))),
    p_metadata => jsonb_build_object(
      'request_id', v_existing.id,
      'request_type', v_existing.request_type
    )
  );

  return query
  select
    v_existing.id,
    v_existing.request_type,
    v_existing.status,
    v_existing.created_at,
    'Password reset request submitted.'::text;
end;
$$;

create or replace function public.app_complete_approved_password_reset(
  p_new_password text
)
returns boolean
language plpgsql
security definer
set search_path = public, auth, extensions
as $$
declare
  v_user_id bigint := public.app_current_user_id();
  v_session_auth_uid uuid := auth.uid();
  v_user public.users%rowtype;
  v_request public.account_requests%rowtype;
  v_auth_uid uuid;
  v_auth_email text;
  v_auth_synced boolean := false;
  v_created_auth_user boolean := false;
begin
  if v_user_id is null then
    raise exception 'Not authenticated.';
  end if;

  if length(coalesce(p_new_password, '')) < 8 then
    raise exception 'Password must be at least 8 characters.';
  end if;

  select *
    into v_request
  from public.account_requests r
  where r.requester_user_id = v_user_id
    and lower(trim(coalesce(r.request_type, ''))) = 'password_reset'
    and lower(trim(coalesce(r.status, ''))) = 'approved'
  order by coalesce(r.updated_at, r.created_at, to_timestamp(0)) desc, r.id desc
  limit 1
  for update;

  if not found then
    raise exception 'No approved password reset request found.';
  end if;

  update public.account_requests
     set status = 'completed',
         resolved_by_user_id = v_user_id,
         resolved_at = now(),
         updated_at = now(),
         note = coalesce(note, 'Approved request completed by requester.')
   where id = v_request.id
     and lower(trim(coalesce(status, ''))) = 'approved';

  if not found then
    raise exception 'Approved password reset request has already been used.';
  end if;

  select *
    into v_user
  from public.users u
  where u.id = v_user_id
  limit 1;

  if not found then
    raise exception 'User account not found.';
  end if;

  if v_session_auth_uid is not null then
    update public.users
       set auth_uid = v_session_auth_uid,
           updated_at = now()
     where id = v_user_id
       and (auth_uid is null or auth_uid = v_session_auth_uid);
  end if;

  select
    p.auth_uid,
    p.auth_email,
    p.auth_synced,
    p.created_auth_user
    into v_auth_uid,
         v_auth_email,
         v_auth_synced,
         v_created_auth_user
  from public.app_ensure_auth_user_for_password(
    p_user_id => v_user_id,
    p_password => p_new_password
  ) p
  limit 1;

  if not coalesce(v_auth_synced, false) then
    raise exception 'Failed to sync password to Supabase Auth.';
  end if;

  update public.account_requests
     set status = 'completed',
         resolved_by_user_id = v_user_id,
         resolved_at = now(),
         updated_at = now(),
         note = coalesce(note, 'Superseded by completed password reset.')
   where requester_user_id = v_user_id
     and lower(trim(coalesce(request_type, ''))) = 'password_reset'
     and lower(trim(coalesce(status, ''))) in ('pending', 'approved');

  perform public.app_log_status_event(
    p_action => 'password_reset_completed',
    p_category => 'request',
    p_message => format(
      'Password reset completed by "%s" after approval.',
      coalesce(v_user.full_name, v_user.username, v_user.id::text)
    ),
    p_actor_user_id => v_user.id,
    p_actor_username => v_user.username,
    p_actor_role => lower(trim(coalesce(v_user.role, ''))),
    p_target_user_id => v_user.id,
    p_target_username => v_user.username,
    p_target_role => lower(trim(coalesce(v_user.role, ''))),
    p_metadata => jsonb_build_object(
      'request_id', v_request.id,
      'auth_synced', coalesce(v_auth_synced, false),
      'auth_uid', v_auth_uid,
      'auth_email', v_auth_email,
      'created_auth_user', coalesce(v_created_auth_user, false)
    )
  );

  return true;
end;
$$;

grant execute on function public.app_request_password_reset(text) to authenticated;
grant execute on function public.app_complete_approved_password_reset(text) to authenticated;

do $$
begin
  perform pg_notify('pgrst', 'reload schema');
exception
  when undefined_function then
    null;
end $$;

-- ---------------------------------------------------------------------------
-- PASSWORD RESET REQUEST ONE-TIME ENFORCEMENT V4 (must stay last)
-- ---------------------------------------------------------------------------
create or replace function public.app_request_password_reset(
  p_note text default null
)
returns table (
  id bigint,
  request_type text,
  status text,
  created_at timestamptz,
  message text
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id bigint := public.app_current_user_id();
  v_user public.users%rowtype;
  v_existing public.account_requests%rowtype;
  v_note text := nullif(trim(coalesce(p_note, '')), '');
begin
  if v_user_id is null then
    raise exception 'Not authenticated.';
  end if;

  select *
    into v_user
  from public.users u
  where u.id = v_user_id
  limit 1;

  if not found then
    raise exception 'User account not found.';
  end if;

  select *
    into v_existing
  from public.account_requests r
  where r.requester_user_id = v_user_id
    and lower(trim(coalesce(r.request_type, ''))) = 'password_reset'
    and lower(trim(coalesce(r.status, ''))) in ('pending', 'approved')
  order by
    case
      when lower(trim(coalesce(r.status, ''))) = 'approved' then 0
      else 1
    end,
    coalesce(r.updated_at, r.created_at, to_timestamp(0)) desc,
    r.id desc
  limit 1;

  if found then
    return query
    select
      v_existing.id,
      v_existing.request_type,
      v_existing.status,
      v_existing.created_at,
      case
        when lower(trim(coalesce(v_existing.status, ''))) = 'approved'
          then 'Your password reset request is already approved. Please reset your password now.'::text
        else 'A pending password reset request already exists.'::text
      end;
    return;
  end if;

  insert into public.account_requests (
    request_type,
    status,
    requester_user_id,
    requester_username,
    requester_full_name,
    requester_role,
    note
  )
  values (
    'password_reset',
    'pending',
    v_user.id,
    v_user.username,
    v_user.full_name,
    lower(trim(coalesce(v_user.role, ''))),
    v_note
  )
  returning * into v_existing;

  perform public.app_log_status_event(
    p_action => 'password_reset_request_submitted',
    p_category => 'request',
    p_message => format(
      'Password reset request submitted by "%s".',
      coalesce(v_user.full_name, v_user.username, v_user.id::text)
    ),
    p_actor_user_id => v_user.id,
    p_actor_username => v_user.username,
    p_actor_role => lower(trim(coalesce(v_user.role, ''))),
    p_target_user_id => v_user.id,
    p_target_username => v_user.username,
    p_target_role => lower(trim(coalesce(v_user.role, ''))),
    p_metadata => jsonb_build_object(
      'request_id', v_existing.id,
      'request_type', v_existing.request_type
    )
  );

  return query
  select
    v_existing.id,
    v_existing.request_type,
    v_existing.status,
    v_existing.created_at,
    'Password reset request submitted.'::text;
end;
$$;

create or replace function public.app_complete_approved_password_reset(
  p_new_password text
)
returns boolean
language plpgsql
security definer
set search_path = public, auth, extensions
as $$
declare
  v_user_id bigint := public.app_current_user_id();
  v_session_auth_uid uuid := auth.uid();
  v_user public.users%rowtype;
  v_request public.account_requests%rowtype;
  v_auth_uid uuid;
  v_auth_email text;
  v_auth_synced boolean := false;
  v_created_auth_user boolean := false;
begin
  if v_user_id is null then
    raise exception 'Not authenticated.';
  end if;

  if length(coalesce(p_new_password, '')) < 8 then
    raise exception 'Password must be at least 8 characters.';
  end if;

  select *
    into v_request
  from public.account_requests r
  where r.requester_user_id = v_user_id
    and lower(trim(coalesce(r.request_type, ''))) = 'password_reset'
    and lower(trim(coalesce(r.status, ''))) = 'approved'
  order by coalesce(r.updated_at, r.created_at, to_timestamp(0)) desc, r.id desc
  limit 1
  for update;

  if not found then
    raise exception 'No approved password reset request found.';
  end if;

  update public.account_requests
     set status = 'completed',
         resolved_by_user_id = v_user_id,
         resolved_at = now(),
         updated_at = now(),
         note = coalesce(note, 'Approved request completed by requester.')
   where id = v_request.id
     and lower(trim(coalesce(status, ''))) = 'approved';

  if not found then
    raise exception 'Approved password reset request has already been used.';
  end if;

  select *
    into v_user
  from public.users u
  where u.id = v_user_id
  limit 1;

  if not found then
    raise exception 'User account not found.';
  end if;

  if v_session_auth_uid is not null then
    update public.users
       set auth_uid = v_session_auth_uid,
           updated_at = now()
     where id = v_user_id
       and (auth_uid is null or auth_uid = v_session_auth_uid);
  end if;

  select
    p.auth_uid,
    p.auth_email,
    p.auth_synced,
    p.created_auth_user
    into v_auth_uid,
         v_auth_email,
         v_auth_synced,
         v_created_auth_user
  from public.app_ensure_auth_user_for_password(
    p_user_id => v_user_id,
    p_password => p_new_password
  ) p
  limit 1;

  if not coalesce(v_auth_synced, false) then
    raise exception 'Failed to sync password to Supabase Auth.';
  end if;

  update public.account_requests
     set status = 'completed',
         resolved_by_user_id = v_user_id,
         resolved_at = now(),
         updated_at = now(),
         note = coalesce(note, 'Superseded by completed password reset.')
   where requester_user_id = v_user_id
     and lower(trim(coalesce(request_type, ''))) = 'password_reset'
     and lower(trim(coalesce(status, ''))) in ('pending', 'approved');

  perform public.app_log_status_event(
    p_action => 'password_reset_completed',
    p_category => 'request',
    p_message => format(
      'Password reset completed by "%s" after approval.',
      coalesce(v_user.full_name, v_user.username, v_user.id::text)
    ),
    p_actor_user_id => v_user.id,
    p_actor_username => v_user.username,
    p_actor_role => lower(trim(coalesce(v_user.role, ''))),
    p_target_user_id => v_user.id,
    p_target_username => v_user.username,
    p_target_role => lower(trim(coalesce(v_user.role, ''))),
    p_metadata => jsonb_build_object(
      'request_id', v_request.id,
      'auth_synced', coalesce(v_auth_synced, false),
      'auth_uid', v_auth_uid,
      'auth_email', v_auth_email,
      'created_auth_user', coalesce(v_created_auth_user, false)
    )
  );

  return true;
end;
$$;

grant execute on function public.app_request_password_reset(text) to authenticated;
grant execute on function public.app_complete_approved_password_reset(text) to authenticated;

do $$
begin
  perform pg_notify('pgrst', 'reload schema');
exception
  when undefined_function then
    null;
end $$;

-- ---------------------------------------------------------------------------
-- FINAL AUTH-ONLY OVERRIDE V1 (authoritative last definitions)
-- ---------------------------------------------------------------------------
-- Auth authority is Supabase Auth only.
-- public.users is profile/role storage only.

create or replace function public.app_password_matches_user(
  p_user_id bigint,
  p_password text
)
returns boolean
language sql
stable
security definer
set search_path = public, auth, extensions
as $$
  with target_user as (
    select
      u.id,
      u.auth_uid,
      lower(public.app_username_auth_email(u.username, u.id)) as auth_email
    from public.users u
    where u.id = p_user_id
    limit 1
  ),
  ranked_auth as (
    select
      au.encrypted_password,
      row_number() over (
        order by
          case
            when tu.auth_uid is not null and au.id = tu.auth_uid then 0
            when lower(coalesce(au.email, '')) = tu.auth_email then 1
            else 9
          end,
          au.created_at desc nulls last
      ) as rn
    from target_user tu
    join auth.users au
      on (
        (tu.auth_uid is not null and au.id = tu.auth_uid)
        or lower(coalesce(au.email, '')) = tu.auth_email
      )
  ),
  chosen as (
    select ra.encrypted_password
    from ranked_auth ra
    where ra.rn = 1
    limit 1
  )
  select coalesce(
    (
      select
        coalesce(c.encrypted_password, '') <> ''
        and (
          c.encrypted_password = crypt(coalesce(p_password, ''), c.encrypted_password)
          or (
            c.encrypted_password like '$2y$%'
            and replace(c.encrypted_password, '$2y$', '$2a$')
              = crypt(
                  coalesce(p_password, ''),
                  replace(c.encrypted_password, '$2y$', '$2a$')
                )
          )
          or (
            c.encrypted_password like '$2b$%'
            and replace(c.encrypted_password, '$2b$', '$2a$')
              = crypt(
                  coalesce(p_password, ''),
                  replace(c.encrypted_password, '$2b$', '$2a$')
                )
          )
        )
      from chosen c
      limit 1
    ),
    false
  );
$$;

create or replace function public.app_login(
  p_identifier text,
  p_password text
)
returns table (
  id bigint,
  username text,
  full_name text,
  role text,
  roles jsonb,
  sub_role text,
  sub_roles jsonb,
  school_id text,
  image_path text,
  auth_uid uuid,
  auth_email text,
  created_at timestamptz,
  updated_at timestamptz
)
language sql
security definer
set search_path = public, auth, extensions
as $$
  with target_user as (
    select
      u.*,
      lower(public.app_username_auth_email(u.username, u.id)) as canonical_auth_email
    from public.users u
    where lower(trim(coalesce(u.username, ''))) = lower(trim(coalesce(p_identifier, '')))
      and (u.expires_at is null or u.expires_at > now())
    order by
      case when u.auth_uid is not null then 0 else 1 end,
      coalesce(u.updated_at, u.created_at, to_timestamp(0)) desc,
      u.id desc
    limit 1
  ),
  ranked_auth as (
    select
      au.id as resolved_auth_uid,
      lower(trim(coalesce(au.email, ''))) as resolved_auth_email,
      au.encrypted_password,
      row_number() over (
        order by
          case
            when tu.auth_uid is not null and au.id = tu.auth_uid then 0
            when lower(coalesce(au.email, '')) = tu.canonical_auth_email then 1
            else 9
          end,
          au.created_at desc nulls last
      ) as rn
    from target_user tu
    join auth.users au
      on (
        (tu.auth_uid is not null and au.id = tu.auth_uid)
        or lower(coalesce(au.email, '')) = tu.canonical_auth_email
      )
  ),
  matched_auth as (
    select
      ra.resolved_auth_uid,
      ra.resolved_auth_email
    from ranked_auth ra
    where ra.rn = 1
      and coalesce(ra.encrypted_password, '') <> ''
      and (
        ra.encrypted_password = crypt(coalesce(p_password, ''), ra.encrypted_password)
        or (
          ra.encrypted_password like '$2y$%'
          and replace(ra.encrypted_password, '$2y$', '$2a$')
            = crypt(
                coalesce(p_password, ''),
                replace(ra.encrypted_password, '$2y$', '$2a$')
              )
        )
        or (
          ra.encrypted_password like '$2b$%'
          and replace(ra.encrypted_password, '$2b$', '$2a$')
            = crypt(
                coalesce(p_password, ''),
                replace(ra.encrypted_password, '$2b$', '$2a$')
              )
        )
      )
    limit 1
  )
  select
    tu.id,
    tu.username,
    tu.full_name,
    tu.role,
    tu.roles,
    tu.sub_role,
    tu.sub_roles,
    tu.school_id,
    tu.image_path,
    coalesce(ma.resolved_auth_uid, tu.auth_uid) as auth_uid,
    coalesce(nullif(ma.resolved_auth_email, ''), tu.canonical_auth_email) as auth_email,
    tu.created_at,
    tu.updated_at
  from target_user tu
  join matched_auth ma
    on true
  limit 1;
$$;

create or replace function public.app_register_user(
  p_username text,
  p_password_hash text,
  p_full_name text,
  p_school_id text,
  p_role text default 'student',
  p_auth_uid uuid default null,
  p_expires_at timestamptz default null
)
returns table (
  id bigint,
  username text,
  full_name text,
  role text,
  roles jsonb,
  sub_role text,
  sub_roles jsonb,
  school_id text,
  image_path text,
  auth_uid uuid,
  expires_at timestamptz,
  created_at timestamptz,
  updated_at timestamptz
)
language plpgsql
security definer
set search_path = public, extensions
as $$
declare
  v_username text := trim(coalesce(p_username, ''));
  v_full_name text := trim(coalesce(p_full_name, ''));
  v_school_id text := trim(coalesce(p_school_id, ''));
  v_role text := lower(trim(coalesce(p_role, 'student')));
  v_password_input text := coalesce(p_password_hash, '');
  v_generated_school_id text := null;
  v_attempt integer := 0;
  v_inserted public.users%rowtype;
begin
  if not public.app_is_admin() then
    raise exception 'Only administrators can create accounts.';
  end if;

  if v_username = '' then
    raise exception 'Username is required.';
  end if;
  if v_full_name = '' then
    raise exception 'Full name is required.';
  end if;

  if v_password_input = '' then
    raise exception 'Password is required.';
  end if;
  if v_password_input not like '$2a$%' and v_password_input not like '$2b$%' and v_password_input not like '$2y$%' then
    if length(v_password_input) < 8 then
      raise exception 'Password must be at least 8 characters.';
    end if;
  end if;

  if v_role not in ('student', 'teacher', 'admin', 'nt') then
    raise exception 'Invalid role.';
  end if;

  if exists (
    select 1
    from public.users u
    where lower(u.username) = lower(v_username)
  ) then
    raise exception 'Username already exists.';
  end if;

  if v_school_id = '' then
    loop
      v_attempt := v_attempt + 1;
      if v_attempt > 500 then
        raise exception 'Unable to generate unique school ID.';
      end if;

      v_generated_school_id := format(
        '%s - %s',
        to_char(now(), 'YYYY'),
        lpad((floor(random() * 10000)::int)::text, 4, '0')
      );

      exit when not exists (
        select 1
        from public.users u
        where trim(coalesce(u.school_id, '')) = v_generated_school_id
      );
    end loop;

    v_school_id := v_generated_school_id;
  end if;

  insert into public.users (
    username,
    full_name,
    role,
    roles,
    sub_role,
    sub_roles,
    school_id,
    image_path,
    auth_uid,
    expires_at
  )
  values (
    v_username,
    v_full_name,
    v_role,
    jsonb_build_array(v_role),
    null,
    '[]'::jsonb,
    nullif(v_school_id, ''),
    '/images/sample.jpg',
    p_auth_uid,
    p_expires_at
  )
  returning * into v_inserted;

  return query
  select
    v_inserted.id,
    v_inserted.username,
    v_inserted.full_name,
    v_inserted.role,
    v_inserted.roles,
    v_inserted.sub_role,
    v_inserted.sub_roles,
    v_inserted.school_id,
    v_inserted.image_path,
    v_inserted.auth_uid,
    v_inserted.expires_at,
    v_inserted.created_at,
    v_inserted.updated_at;
end;
$$;

create or replace function public.app_admin_set_user_password(
  p_user_id bigint,
  p_new_password text
)
returns table (
  id bigint,
  auth_uid uuid,
  auth_synced boolean
)
language plpgsql
security definer
set search_path = public
as $$
begin
  raise exception 'Password reset must use set-auth-password edge function (auth.admin flow).';
end;
$$;

revoke execute on function public.app_admin_set_user_password(bigint, text) from anon;
revoke execute on function public.app_admin_set_user_password(bigint, text) from authenticated;
revoke execute on function public.app_repair_auth_profile_for_login(text, text) from anon;
revoke execute on function public.app_repair_auth_profile_for_login(text, text) from authenticated;
revoke execute on function public.app_ensure_auth_user_for_password(bigint, text) from authenticated;
revoke execute on function public.app_ensure_auth_user_for_hash(bigint, text) from authenticated;
grant execute on function public.app_login(text, text) to anon, authenticated;
grant execute on function public.app_password_matches_user(bigint, text) to authenticated;
grant execute on function public.app_register_user(text, text, text, text, text, uuid, timestamptz) to authenticated;

do $$
begin
  perform pg_notify('pgrst', 'reload schema');
exception
  when undefined_function then
    null;
end $$;

-- ---------------------------------------------------------------------------
-- FINAL AUTH HOTFIX OVERRIDE V3 (authoritative tail)
-- ---------------------------------------------------------------------------
-- This block must stay LAST so earlier duplicate definitions cannot override it.

create or replace function public.app_password_matches_user(
  p_user_id bigint,
  p_password text
)
returns boolean
language sql
stable
security definer
set search_path = public, auth, extensions
as $$
  with target_user as (
    select
      u.id,
      u.auth_uid,
      coalesce(u.password, '') as legacy_password,
      lower(public.app_username_auth_email(u.username, u.id)) as auth_email
    from public.users u
    where u.id = p_user_id
    limit 1
  ),
  ranked_auth as (
    select
      au.encrypted_password,
      row_number() over (
        order by
          case
            when tu.auth_uid is not null
                 and au.id = tu.auth_uid
                 and lower(coalesce(au.email, '')) = tu.auth_email then 0
            when lower(coalesce(au.email, '')) = tu.auth_email then 1
            when tu.auth_uid is not null and au.id = tu.auth_uid then 2
            else 9
          end,
          au.created_at desc nulls last
      ) as rn
    from target_user tu
    join auth.users au
      on (
        lower(coalesce(au.email, '')) = tu.auth_email
        or (tu.auth_uid is not null and au.id = tu.auth_uid)
      )
  ),
  picked_auth as (
    select ra.encrypted_password
    from ranked_auth ra
    where ra.rn = 1
    limit 1
  ),
  auth_match as (
    select
      coalesce(pa.encrypted_password, '') <> ''
      and (
        pa.encrypted_password = crypt(coalesce(p_password, ''), pa.encrypted_password)
        or (
          pa.encrypted_password like '$2y$%'
          and replace(pa.encrypted_password, '$2y$', '$2a$')
            = crypt(
                coalesce(p_password, ''),
                replace(pa.encrypted_password, '$2y$', '$2a$')
              )
        )
        or (
          pa.encrypted_password like '$2b$%'
          and replace(pa.encrypted_password, '$2b$', '$2a$')
            = crypt(
                coalesce(p_password, ''),
                replace(pa.encrypted_password, '$2b$', '$2a$')
              )
        )
      ) as ok
    from picked_auth pa
    limit 1
  ),
  legacy_match as (
    select
      coalesce(tu.legacy_password, '') <> ''
      and (
        tu.legacy_password = crypt(coalesce(p_password, ''), tu.legacy_password)
        or (
          tu.legacy_password like '$2y$%'
          and replace(tu.legacy_password, '$2y$', '$2a$')
            = crypt(
                coalesce(p_password, ''),
                replace(tu.legacy_password, '$2y$', '$2a$')
              )
        )
        or (
          tu.legacy_password like '$2b$%'
          and replace(tu.legacy_password, '$2b$', '$2a$')
            = crypt(
                coalesce(p_password, ''),
                replace(tu.legacy_password, '$2b$', '$2a$')
              )
        )
        or (
          tu.legacy_password not like '$2%'
          and tu.legacy_password = coalesce(p_password, '')
        )
      ) as ok
    from target_user tu
    limit 1
  )
  select
    coalesce((select ok from auth_match limit 1), false)
    or coalesce((select ok from legacy_match limit 1), false);
$$;

create or replace function public.app_login(
  p_identifier text,
  p_password text
)
returns table (
  id bigint,
  username text,
  full_name text,
  role text,
  roles jsonb,
  sub_role text,
  sub_roles jsonb,
  school_id text,
  image_path text,
  auth_uid uuid,
  auth_email text,
  created_at timestamptz,
  updated_at timestamptz
)
language sql
security definer
set search_path = public, auth, extensions
as $$
  with target_user as (
    select
      u.*,
      lower(public.app_username_auth_email(u.username, u.id)) as canonical_auth_email
    from public.users u
    where lower(trim(coalesce(u.username, ''))) = lower(trim(coalesce(p_identifier, '')))
      and public.app_password_matches_user(u.id, coalesce(p_password, ''))
      and (u.expires_at is null or u.expires_at > now())
  )
  select
    u.id,
    u.username,
    u.full_name,
    u.role,
    u.roles,
    u.sub_role,
    u.sub_roles,
    u.school_id,
    u.image_path,
    u.auth_uid,
    case
      when lower(trim(coalesce(au.email, ''))) = u.canonical_auth_email
        then lower(trim(coalesce(au.email, '')))
      else u.canonical_auth_email
    end as auth_email,
    u.created_at,
    u.updated_at
  from target_user u
  left join auth.users au
    on au.id = u.auth_uid
  order by
    case
      when u.auth_uid is not null
           and lower(trim(coalesce(au.email, ''))) = u.canonical_auth_email then 0
      when u.auth_uid is not null then 1
      else 2
    end,
    coalesce(u.updated_at, u.created_at, to_timestamp(0)) desc,
    u.id desc
  limit 1;
$$;

create or replace function public.app_repair_auth_profile_for_login(
  p_identifier text,
  p_password text
)
returns table (
  auth_uid uuid,
  auth_email text,
  auth_synced boolean,
  created_auth_user boolean
)
language plpgsql
security definer
set search_path = public, auth, extensions
as $$
declare
  v_identifier text := trim(coalesce(p_identifier, ''));
  v_password text := coalesce(p_password, '');
  v_user_id bigint;
  v_expected_email text;
begin
  if v_identifier = '' or v_password = '' then
    return;
  end if;

  select
    u.id,
    public.app_username_auth_email(u.username, u.id)
  into v_user_id, v_expected_email
  from public.users u
  where lower(trim(coalesce(u.username, ''))) = lower(v_identifier)
    and (u.expires_at is null or u.expires_at > now())
    and public.app_password_matches_user(u.id, v_password)
  order by
    case when u.auth_uid is not null then 0 else 1 end,
    coalesce(u.updated_at, u.created_at, to_timestamp(0)) desc,
    u.id desc
  limit 1;

  if not found then
    return;
  end if;

  update public.users u
     set auth_uid = null,
         updated_at = now()
   where u.id = v_user_id
     and u.auth_uid is not null
     and (
       not exists (
         select 1
         from auth.users au
         where au.id = u.auth_uid
       )
       or exists (
         select 1
         from auth.users au
         where au.id = u.auth_uid
           and lower(coalesce(au.email, '')) <> lower(coalesce(v_expected_email, ''))
       )
     );

  return query
  select
    p.auth_uid,
    p.auth_email,
    p.auth_synced,
    p.created_auth_user
  from public.app_ensure_auth_user_for_password(
    p_user_id => v_user_id,
    p_password => v_password
  ) p
  limit 1;
end;
$$;

grant execute on function public.app_login(text, text) to anon, authenticated;
grant execute on function public.app_password_matches_user(bigint, text) to authenticated;
grant execute on function public.app_repair_auth_profile_for_login(text, text) to anon, authenticated;

do $$
begin
  perform pg_notify('pgrst', 'reload schema');
exception
  when undefined_function then
    null;
end $$;

-- ---------------------------------------------------------------------------
-- FINAL AUTH HOTFIX OVERRIDE V2 (stale auth_uid resilience)
-- ---------------------------------------------------------------------------
-- Ensures password matching prefers canonical username-email linkage and
-- app_login always returns the canonical auth email when mapping is stale.

create or replace function public.app_password_matches_user(
  p_user_id bigint,
  p_password text
)
returns boolean
language sql
stable
security definer
set search_path = public, auth, extensions
as $$
  with target_user as (
    select
      u.id,
      u.auth_uid,
      coalesce(u.password, '') as legacy_password,
      lower(public.app_username_auth_email(u.username, u.id)) as auth_email
    from public.users u
    where u.id = p_user_id
    limit 1
  ),
  target_auth as (
    select
      au.encrypted_password,
      row_number() over (
        order by
          case
            when tu.auth_uid is not null
                 and au.id = tu.auth_uid
                 and lower(coalesce(au.email, '')) = tu.auth_email then 0
            when lower(coalesce(au.email, '')) = tu.auth_email then 1
            when tu.auth_uid is not null and au.id = tu.auth_uid then 2
            else 9
          end,
          au.created_at desc nulls last
      ) as rn
    from target_user tu
    join auth.users au
      on (
        lower(coalesce(au.email, '')) = tu.auth_email
        or (tu.auth_uid is not null and au.id = tu.auth_uid)
      )
  ),
  picked_auth as (
    select ta.encrypted_password
    from target_auth ta
    where ta.rn = 1
    limit 1
  ),
  auth_match as (
    select
      coalesce(pa.encrypted_password, '') <> ''
      and (
        pa.encrypted_password = crypt(coalesce(p_password, ''), pa.encrypted_password)
        or (
          pa.encrypted_password like '$2y$%'
          and replace(pa.encrypted_password, '$2y$', '$2a$')
            = crypt(
                coalesce(p_password, ''),
                replace(pa.encrypted_password, '$2y$', '$2a$')
              )
        )
        or (
          pa.encrypted_password like '$2b$%'
          and replace(pa.encrypted_password, '$2b$', '$2a$')
            = crypt(
                coalesce(p_password, ''),
                replace(pa.encrypted_password, '$2b$', '$2a$')
              )
        )
      ) as ok
    from picked_auth pa
    limit 1
  ),
  legacy_match as (
    select
      coalesce(tu.legacy_password, '') <> ''
      and (
        tu.legacy_password = crypt(coalesce(p_password, ''), tu.legacy_password)
        or (
          tu.legacy_password like '$2y$%'
          and replace(tu.legacy_password, '$2y$', '$2a$')
            = crypt(
                coalesce(p_password, ''),
                replace(tu.legacy_password, '$2y$', '$2a$')
              )
        )
        or (
          tu.legacy_password like '$2b$%'
          and replace(tu.legacy_password, '$2b$', '$2a$')
            = crypt(
                coalesce(p_password, ''),
                replace(tu.legacy_password, '$2b$', '$2a$')
              )
        )
        or (
          tu.legacy_password not like '$2%'
          and tu.legacy_password = coalesce(p_password, '')
        )
      ) as ok
    from target_user tu
    limit 1
  )
  select
    coalesce((select ok from auth_match limit 1), false)
    or coalesce((select ok from legacy_match limit 1), false);
$$;

create or replace function public.app_login(
  p_identifier text,
  p_password text
)
returns table (
  id bigint,
  username text,
  full_name text,
  role text,
  roles jsonb,
  sub_role text,
  sub_roles jsonb,
  school_id text,
  image_path text,
  auth_uid uuid,
  auth_email text,
  created_at timestamptz,
  updated_at timestamptz
)
language sql
security definer
set search_path = public, auth, extensions
as $$
  with target_user as (
    select
      u.*,
      lower(public.app_username_auth_email(u.username, u.id)) as canonical_auth_email
    from public.users u
    where lower(trim(coalesce(u.username, ''))) = lower(trim(coalesce(p_identifier, '')))
      and public.app_password_matches_user(u.id, coalesce(p_password, ''))
      and (u.expires_at is null or u.expires_at > now())
  )
  select
    u.id,
    u.username,
    u.full_name,
    u.role,
    u.roles,
    u.sub_role,
    u.sub_roles,
    u.school_id,
    u.image_path,
    u.auth_uid,
    case
      when lower(trim(coalesce(au.email, ''))) = u.canonical_auth_email
        then lower(trim(coalesce(au.email, '')))
      else u.canonical_auth_email
    end as auth_email,
    u.created_at,
    u.updated_at
  from target_user u
  left join auth.users au
    on au.id = u.auth_uid
  order by
    case
      when u.auth_uid is not null
           and lower(trim(coalesce(au.email, ''))) = u.canonical_auth_email then 0
      when u.auth_uid is not null then 1
      else 2
    end,
    coalesce(u.updated_at, u.created_at, to_timestamp(0)) desc,
    u.id desc
  limit 1;
$$;

grant execute on function public.app_login(text, text) to anon, authenticated;
grant execute on function public.app_password_matches_user(bigint, text) to authenticated;

do $$
begin
  perform pg_notify('pgrst', 'reload schema');
exception
  when undefined_function then
    null;
end $$;

-- ---------------------------------------------------------------------------
-- Backfill/repair secure auth profiles for existing users
-- ---------------------------------------------------------------------------
do $$
declare
  v_user record;
  v_expected_auth_email text;
begin
  for v_user in
    select
      u.id,
      u.username,
      u.password,
      u.auth_uid
    from public.users u
    where coalesce(trim(u.password), '') <> ''
  loop
    v_expected_auth_email := public.app_username_auth_email(v_user.username, v_user.id);

    if v_user.auth_uid is null
       or not exists (
         select 1
         from auth.users au
         where au.id = v_user.auth_uid
       )
       or not exists (
         select 1
         from auth.identities ai
         where ai.user_id = v_user.auth_uid
           and ai.provider = 'email'
           and lower(coalesce(ai.provider_id, '')) = v_expected_auth_email
       ) then
      begin
        if v_user.password like '$2a$%'
           or v_user.password like '$2b$%'
           or v_user.password like '$2y$%' then
          perform 1
          from public.app_ensure_auth_user_for_hash(v_user.id, v_user.password) p
          where coalesce(p.auth_synced, false)
          limit 1;
        else
          perform 1
          from public.app_ensure_auth_user_for_password(v_user.id, v_user.password) p
          where coalesce(p.auth_synced, false)
          limit 1;
        end if;
      exception
        when others then
          null;
      end;
    end if;
  end loop;
end $$;

-- ---------------------------------------------------------------------------
-- Enable RLS on every public table and reset existing policies
-- ---------------------------------------------------------------------------
do $$
declare
  t record;
  p record;
begin
  for t in
    select tablename
    from pg_tables
    where schemaname = 'public'
  loop
    execute format('alter table public.%I enable row level security', t.tablename);
  end loop;

  for p in
    select tablename, policyname
    from pg_policies
    where schemaname = 'public'
  loop
    execute format('drop policy if exists %I on public.%I', p.policyname, p.tablename);
  end loop;
end $$;

-- ---------------------------------------------------------------------------
-- Table policies
-- ---------------------------------------------------------------------------

-- users
create policy rls_users_select_self_or_admin
on public.users
for select
to authenticated
using (public.app_is_admin() or id = public.app_current_user_id());

create policy rls_users_insert_admin_only
on public.users
for insert
to authenticated
with check (public.app_is_admin());

create policy rls_users_update_self_or_admin
on public.users
for update
to authenticated
using (public.app_is_admin() or id = public.app_current_user_id())
with check (public.app_is_admin() or id = public.app_current_user_id());

create policy rls_users_delete_admin_only
on public.users
for delete
to authenticated
using (public.app_is_admin());

create policy rls_status_logs_select_admin
on public.status_logs
for select
to authenticated
using (public.app_is_admin());

create policy rls_status_logs_write_admin
on public.status_logs
for all
to authenticated
using (public.app_is_admin())
with check (public.app_is_admin());

create policy rls_account_requests_select_scope
on public.account_requests
for select
to authenticated
using (
  public.app_is_admin()
  or requester_user_id = public.app_current_user_id()
);

create policy rls_account_requests_insert_self
on public.account_requests
for insert
to authenticated
with check (
  requester_user_id = public.app_current_user_id()
);

create policy rls_account_requests_update_admin
on public.account_requests
for update
to authenticated
using (public.app_is_admin())
with check (public.app_is_admin());

create policy rls_account_requests_delete_admin
on public.account_requests
for delete
to authenticated
using (public.app_is_admin());

-- core lookup tables
create policy rls_buildings_select_auth on public.buildings for select to authenticated using (true);
create policy rls_buildings_write_staff on public.buildings for all to authenticated
using (public.app_is_admin() or public.app_is_staff())
with check (public.app_is_admin() or public.app_is_staff());

create policy rls_rooms_select_auth on public.rooms for select to authenticated using (true);
create policy rls_rooms_write_staff on public.rooms for all to authenticated
using (public.app_is_admin() or public.app_is_staff())
with check (public.app_is_admin() or public.app_is_staff());

create policy rls_sections_select_auth on public.sections for select to authenticated using (true);
create policy rls_sections_write_staff on public.sections for all to authenticated
using (public.app_is_admin() or public.app_is_staff())
with check (public.app_is_admin() or public.app_is_staff());

create policy rls_subjects_select_auth on public.subjects for select to authenticated using (true);
create policy rls_subjects_write_staff on public.subjects for all to authenticated
using (public.app_is_admin() or public.app_is_staff())
with check (public.app_is_admin() or public.app_is_staff());

create policy rls_section_assignments_select_auth on public.section_assignments for select to authenticated using (true);
create policy rls_section_assignments_write_staff on public.section_assignments for all to authenticated
using (public.app_is_admin() or public.app_is_staff())
with check (public.app_is_admin() or public.app_is_staff());

create policy rls_teacher_assignments_select_auth on public.teacher_assignments for select to authenticated using (true);
create policy rls_teacher_assignments_write_staff on public.teacher_assignments for all to authenticated
using (public.app_is_admin() or public.app_is_staff())
with check (public.app_is_admin() or public.app_is_staff());

create policy rls_schedules_select_auth on public.schedules for select to authenticated using (true);
create policy rls_schedules_write_staff on public.schedules for all to authenticated
using (public.app_is_admin() or public.app_is_staff())
with check (public.app_is_admin() or public.app_is_staff());

create policy rls_section_subjects_select_auth on public.section_subjects for select to authenticated using (true);
create policy rls_section_subjects_write_staff on public.section_subjects for all to authenticated
using (public.app_is_admin() or public.app_is_staff())
with check (public.app_is_admin() or public.app_is_staff());

create policy rls_settings_select_auth on public.settings for select to authenticated using (true);
create policy rls_settings_write_admin on public.settings for all to authenticated
using (public.app_is_admin())
with check (public.app_is_admin());

create policy rls_eval_settings_select_auth on public.evaluation_settings for select to authenticated using (true);
create policy rls_eval_settings_write_admin on public.evaluation_settings for all to authenticated
using (public.app_is_admin())
with check (public.app_is_admin());

-- announcements and projects
create policy rls_announcements_select_targeted
on public.announcements
for select
to authenticated
using (
  coalesce(lower(target_role), 'all') = 'all'
  or (lower(coalesce(target_role, '')) = 'student' and public.app_is_student())
  or (lower(coalesce(target_role, '')) in ('teacher', 'faculty') and public.app_is_teacher())
  or (lower(coalesce(target_role, '')) in ('nt', 'staff', 'osas', 'treasury') and public.app_is_staff())
  or (lower(coalesce(target_role, '')) = 'admin' and public.app_is_admin())
);

create policy rls_announcements_write_staff_teacher
on public.announcements
for all
to authenticated
using (public.app_is_admin() or public.app_is_staff() or public.app_is_teacher())
with check (public.app_is_admin() or public.app_is_staff() or public.app_is_teacher());

create policy rls_campus_projects_select_auth on public.campus_projects for select to authenticated using (true);
create policy rls_campus_projects_write_staff_teacher on public.campus_projects for all to authenticated
using (public.app_is_admin() or public.app_is_staff() or public.app_is_teacher())
with check (public.app_is_admin() or public.app_is_staff() or public.app_is_teacher());

create policy rls_projects_select_auth on public.projects for select to authenticated using (true);
create policy rls_projects_insert_staff_teacher on public.projects for insert to authenticated
with check (
  public.app_is_admin()
  or public.app_is_staff()
  or (public.app_is_teacher() and teacher_id = public.app_current_user_id())
);
create policy rls_projects_update_staff_teacher on public.projects for update to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or (public.app_is_teacher() and teacher_id = public.app_current_user_id())
)
with check (
  public.app_is_admin()
  or public.app_is_staff()
  or (public.app_is_teacher() and teacher_id = public.app_current_user_id())
);
create policy rls_projects_delete_staff_teacher on public.projects for delete to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or (public.app_is_teacher() and teacher_id = public.app_current_user_id())
);

-- user/student data
create policy rls_user_assignments_select_scope
on public.user_assignments
for select
to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or public.app_is_teacher()
  or user_id = public.app_current_user_id()
);

create policy rls_user_assignments_write_staff
on public.user_assignments
for all
to authenticated
using (public.app_is_admin() or public.app_is_staff())
with check (public.app_is_admin() or public.app_is_staff());

create policy rls_study_load_select_scope
on public.study_load
for select
to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or public.app_is_teacher()
  or student_id = public.app_current_user_id()
  or exists (
    select 1
    from public.user_assignments ua
    where ua.user_id = public.app_current_user_id()
      and coalesce(lower(ua.status), 'active') = 'active'
      and (
        (study_load.section_id is not null and ua.section_id = study_load.section_id)
        or (study_load.section is not null and ua.section = study_load.section)
      )
  )
);

create policy rls_study_load_write_staff
on public.study_load
for all
to authenticated
using (public.app_is_admin() or public.app_is_staff())
with check (public.app_is_admin() or public.app_is_staff());

create policy rls_grades_select_scope
on public.grades
for select
to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or student_id = public.app_current_user_id()
  or teacher_id = public.app_current_user_id()
);

create policy rls_grades_insert_scope
on public.grades
for insert
to authenticated
with check (
  public.app_is_admin()
  or public.app_is_staff()
  or (public.app_is_teacher() and teacher_id = public.app_current_user_id())
);

create policy rls_grades_update_scope
on public.grades
for update
to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or (public.app_is_teacher() and teacher_id = public.app_current_user_id())
)
with check (
  public.app_is_admin()
  or public.app_is_staff()
  or (public.app_is_teacher() and teacher_id = public.app_current_user_id())
);

create policy rls_grades_delete_scope
on public.grades
for delete
to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or (public.app_is_teacher() and teacher_id = public.app_current_user_id())
);

create policy rls_teacher_evaluations_select_scope
on public.teacher_evaluations
for select
to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or teacher_id = public.app_current_user_id()
  or student_id = public.app_current_user_id()
);

create policy rls_teacher_evaluations_insert_student
on public.teacher_evaluations
for insert
to authenticated
with check (
  student_id = public.app_current_user_id()
);

create policy rls_teacher_evaluations_update_staff
on public.teacher_evaluations
for update
to authenticated
using (public.app_is_admin() or public.app_is_staff())
with check (public.app_is_admin() or public.app_is_staff());

create policy rls_teacher_evaluations_delete_staff
on public.teacher_evaluations
for delete
to authenticated
using (public.app_is_admin() or public.app_is_staff());

create policy rls_feedbacks_select_scope
on public.feedbacks
for select
to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or student_id = public.app_current_user_id()
);

create policy rls_feedbacks_insert_student
on public.feedbacks
for insert
to authenticated
with check (student_id = public.app_current_user_id());

create policy rls_feedbacks_update_scope
on public.feedbacks
for update
to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or student_id = public.app_current_user_id()
)
with check (
  public.app_is_admin()
  or public.app_is_staff()
  or student_id = public.app_current_user_id()
);

create policy rls_feedbacks_delete_scope
on public.feedbacks
for delete
to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or student_id = public.app_current_user_id()
);

create policy rls_attendance_logs_select_scope
on public.attendance_logs
for select
to authenticated
using (
  public.app_is_admin()
  or public.app_is_staff()
  or public.app_is_teacher()
  or user_id = public.app_current_user_id()
);

create policy rls_attendance_logs_write_staff_teacher
on public.attendance_logs
for all
to authenticated
using (public.app_is_admin() or public.app_is_staff() or public.app_is_teacher())
with check (public.app_is_admin() or public.app_is_staff() or public.app_is_teacher());

-- ---------------------------------------------------------------------------
-- Expired account cleanup job (runs every minute)
-- ---------------------------------------------------------------------------
do $$
begin
  if exists (select 1 from pg_extension where extname = 'pg_cron') then
    begin
      if exists (
        select 1
        from cron.job
        where jobname = 'app-purge-expired-users'
      ) then
        perform cron.unschedule(
          (select jobid from cron.job where jobname = 'app-purge-expired-users' limit 1)
        );
      end if;

      perform cron.schedule(
        'app-purge-expired-users',
        '* * * * *',
        $job$select public.app_purge_expired_users();$job$
      );
    exception
      when undefined_table or undefined_function then
        null;
    end;
  end if;
end $$;

-- ---------------------------------------------------------------------------
-- Sequence sync (avoid duplicate users.id on re-runs/imported data)
-- ---------------------------------------------------------------------------
do $$
declare
  v_users_seq text;
begin
  v_users_seq := pg_get_serial_sequence('public.users', 'id');
  if v_users_seq is not null then
    execute format(
      'select setval(%L, coalesce((select max(id) from public.users), 0) + 1, false)',
      v_users_seq
    );
  end if;
end $$;

-- ---------------------------------------------------------------------------
-- Storage (avatars bucket)
-- ---------------------------------------------------------------------------
insert into storage.buckets (id, name, public)
select 'avatars', 'avatars', false
where not exists (
  select 1 from storage.buckets where id = 'avatars'
);

drop policy if exists "avatars_select_authenticated" on storage.objects;
create policy "avatars_select_authenticated"
on storage.objects
for select
to authenticated
using (bucket_id = 'avatars');

drop policy if exists "avatars_insert_owner_or_staff" on storage.objects;
create policy "avatars_insert_owner_or_staff"
on storage.objects
for insert
to authenticated
with check (
  bucket_id = 'avatars'
  and (
    public.app_is_admin()
    or public.app_is_staff()
    or (
      public.app_current_user_id() is not null
      and name like ('profiles/' || public.app_current_user_id()::text || '/%')
    )
  )
);

drop policy if exists "avatars_update_owner_or_staff" on storage.objects;
create policy "avatars_update_owner_or_staff"
on storage.objects
for update
to authenticated
using (
  bucket_id = 'avatars'
  and (
    public.app_is_admin()
    or public.app_is_staff()
    or (
      public.app_current_user_id() is not null
      and name like ('profiles/' || public.app_current_user_id()::text || '/%')
    )
  )
)
with check (
  bucket_id = 'avatars'
  and (
    public.app_is_admin()
    or public.app_is_staff()
    or (
      public.app_current_user_id() is not null
      and name like ('profiles/' || public.app_current_user_id()::text || '/%')
    )
  )
);

drop policy if exists "avatars_delete_owner_or_staff" on storage.objects;
create policy "avatars_delete_owner_or_staff"
on storage.objects
for delete
to authenticated
using (
  bucket_id = 'avatars'
  and (
    public.app_is_admin()
    or public.app_is_staff()
    or (
      public.app_current_user_id() is not null
      and name like ('profiles/' || public.app_current_user_id()::text || '/%')
    )
  )
);

-- ---------------------------------------------------------------------------
-- Optional admin seed template (disabled by default)
-- ---------------------------------------------------------------------------
-- SECURITY NOTE:
-- Do not commit real bootstrap credentials. If you need a local seed, set
-- v_seed_enabled := true and provide a strong v_admin_password before running.
do $$
declare
  v_seed_enabled boolean := false;
  v_admin_username text := 'admin';
  v_admin_password text := null;
begin
  if not v_seed_enabled or nullif(trim(coalesce(v_admin_password, '')), '') is null then
    return;
  end if;

  insert into public.users (
    username,
    password,
    full_name,
    role,
    roles,
    sub_role,
    sub_roles,
    school_id,
    image_path
  )
  select
    v_admin_username,
    extensions.crypt(v_admin_password, extensions.gen_salt('bf', 12)),
    'System Administrator',
    'admin',
    '["admin"]'::jsonb,
    null,
    '[]'::jsonb,
    'ADMIN001',
    '/images/sample.jpg'
  where not exists (
    select 1
    from public.users u
    where lower(u.username) = lower(v_admin_username)
  );
end $$;

-- ---------------------------------------------------------------------------
-- Auth authority hardening overlay (phase out public.users.password)
-- ---------------------------------------------------------------------------
-- Keep public.users as profile/role data; keep auth.users as the only password source.

do $$
begin
  if exists (
    select 1
    from information_schema.columns
    where table_schema = 'public'
      and table_name = 'users'
      and column_name = 'password'
  ) then
    begin
      execute 'alter table public.users alter column password drop not null';
    exception
      when others then
        null;
    end;
  end if;
end $$;

drop trigger if exists trg_app_sync_auth_profile_on_users_change on public.users;

create or replace function public.app_password_matches_user(
  p_user_id bigint,
  p_password text
)
returns boolean
language sql
stable
security definer
set search_path = public, auth, extensions
as $$
  with target_user as (
    select
      u.id,
      u.auth_uid,
      coalesce(u.password, '') as legacy_password,
      lower(public.app_username_auth_email(u.username, u.id)) as auth_email
    from public.users u
    where u.id = p_user_id
    limit 1
  ),
  target_auth as (
    select
      au.encrypted_password,
      row_number() over (
        order by
          case
            when tu.auth_uid is not null
                 and au.id = tu.auth_uid
                 and lower(coalesce(au.email, '')) = tu.auth_email then 0
            when lower(coalesce(au.email, '')) = tu.auth_email then 1
            when tu.auth_uid is not null and au.id = tu.auth_uid then 2
            else 9
          end,
          au.created_at desc nulls last
      ) as rn
    from target_user tu
    join auth.users au
      on (
        lower(coalesce(au.email, '')) = tu.auth_email
        or (tu.auth_uid is not null and au.id = tu.auth_uid)
      )
  ),
  picked_auth as (
    select ta.encrypted_password
    from target_auth ta
    where ta.rn = 1
    limit 1
  ),
  auth_match as (
    select
      coalesce(pa.encrypted_password, '') <> ''
      and (
        pa.encrypted_password = crypt(coalesce(p_password, ''), pa.encrypted_password)
        or (
          pa.encrypted_password like '$2y$%'
          and replace(pa.encrypted_password, '$2y$', '$2a$')
            = crypt(
                coalesce(p_password, ''),
                replace(pa.encrypted_password, '$2y$', '$2a$')
              )
        )
        or (
          pa.encrypted_password like '$2b$%'
          and replace(pa.encrypted_password, '$2b$', '$2a$')
            = crypt(
                coalesce(p_password, ''),
                replace(pa.encrypted_password, '$2b$', '$2a$')
              )
        )
      ) as ok
    from picked_auth pa
    limit 1
  ),
  legacy_match as (
    select
      coalesce(tu.legacy_password, '') <> ''
      and (
        tu.legacy_password = crypt(coalesce(p_password, ''), tu.legacy_password)
        or (
          tu.legacy_password like '$2y$%'
          and replace(tu.legacy_password, '$2y$', '$2a$')
            = crypt(
                coalesce(p_password, ''),
                replace(tu.legacy_password, '$2y$', '$2a$')
              )
        )
        or (
          tu.legacy_password like '$2b$%'
          and replace(tu.legacy_password, '$2b$', '$2a$')
            = crypt(
                coalesce(p_password, ''),
                replace(tu.legacy_password, '$2b$', '$2a$')
              )
        )
        or (
          tu.legacy_password not like '$2%'
          and tu.legacy_password = coalesce(p_password, '')
        )
      ) as ok
    from target_user tu
    limit 1
  )
  select
    coalesce((select ok from auth_match limit 1), false)
    or coalesce((select ok from legacy_match limit 1), false);
$$;

create or replace function public.app_login(
  p_identifier text,
  p_password text
)
returns table (
  id bigint,
  username text,
  full_name text,
  role text,
  roles jsonb,
  sub_role text,
  sub_roles jsonb,
  school_id text,
  image_path text,
  auth_uid uuid,
  auth_email text,
  created_at timestamptz,
  updated_at timestamptz
)
language sql
security definer
set search_path = public, auth, extensions
as $$
  with target_user as (
    select
      u.*,
      lower(public.app_username_auth_email(u.username, u.id)) as canonical_auth_email
    from public.users u
    where lower(trim(coalesce(u.username, ''))) = lower(trim(coalesce(p_identifier, '')))
      and public.app_password_matches_user(u.id, coalesce(p_password, ''))
      and (u.expires_at is null or u.expires_at > now())
  )
  select
    u.id,
    u.username,
    u.full_name,
    u.role,
    u.roles,
    u.sub_role,
    u.sub_roles,
    u.school_id,
    u.image_path,
    u.auth_uid,
    case
      when lower(trim(coalesce(au.email, ''))) = u.canonical_auth_email
        then lower(trim(coalesce(au.email, '')))
      else u.canonical_auth_email
    end as auth_email,
    u.created_at,
    u.updated_at
  from target_user u
  left join auth.users au
    on au.id = u.auth_uid
  order by
    case
      when u.auth_uid is not null
           and lower(trim(coalesce(au.email, ''))) = u.canonical_auth_email then 0
      when u.auth_uid is not null then 1
      else 2
    end,
    coalesce(u.updated_at, u.created_at, to_timestamp(0)) desc,
    u.id desc
  limit 1;
$$;

create or replace function public.app_repair_auth_profile_for_login(
  p_identifier text,
  p_password text
)
returns table (
  auth_uid uuid,
  auth_email text,
  auth_synced boolean,
  created_auth_user boolean
)
language plpgsql
security definer
set search_path = public, auth, extensions
as $$
declare
  v_identifier text := trim(coalesce(p_identifier, ''));
  v_password text := coalesce(p_password, '');
  v_user_id bigint;
begin
  if v_identifier = '' or v_password = '' then
    return;
  end if;

  select
    u.id
  into v_user_id
  from public.users u
  where lower(trim(coalesce(u.username, ''))) = lower(v_identifier)
    and (u.expires_at is null or u.expires_at > now())
    and public.app_password_matches_user(u.id, v_password)
  order by
    case when u.auth_uid is not null then 0 else 1 end,
    coalesce(u.updated_at, u.created_at, to_timestamp(0)) desc,
    u.id desc
  limit 1;

  if not found then
    return;
  end if;

  -- If mapped auth UID was deleted, clear it so ensure function can repair via email.
  update public.users u
     set auth_uid = null,
         updated_at = now()
   where u.id = v_user_id
     and u.auth_uid is not null
     and not exists (
       select 1
       from auth.users au
       where au.id = u.auth_uid
     );

  return query
  select
    p.auth_uid,
    p.auth_email,
    p.auth_synced,
    p.created_auth_user
  from public.app_ensure_auth_user_for_password(
    p_user_id => v_user_id,
    p_password => v_password
  ) p
  limit 1;
end;
$$;

create or replace function public.app_complete_approved_password_reset(
  p_new_password text
)
returns boolean
language plpgsql
security definer
set search_path = public, auth, extensions
as $$
declare
  v_user_id bigint := public.app_current_user_id();
  v_session_auth_uid uuid := auth.uid();
  v_user public.users%rowtype;
  v_request public.account_requests%rowtype;
  v_auth_uid uuid;
  v_auth_email text;
  v_auth_synced boolean := false;
  v_created_auth_user boolean := false;
begin
  if v_user_id is null then
    raise exception 'Not authenticated.';
  end if;

  if length(coalesce(p_new_password, '')) < 8 then
    raise exception 'Password must be at least 8 characters.';
  end if;

  select *
    into v_request
  from public.account_requests r
  where r.requester_user_id = v_user_id
    and lower(coalesce(r.request_type, '')) = 'password_reset'
    and lower(coalesce(r.status, '')) = 'approved'
  order by r.updated_at desc, r.created_at desc
  limit 1;

  if not found then
    raise exception 'No approved password reset request found.';
  end if;

  update public.account_requests
     set status = 'completed',
         resolved_by_user_id = v_user_id,
         resolved_at = now(),
         updated_at = now(),
         note = coalesce(note, 'Approved request completed by requester.')
   where id = v_request.id
     and lower(coalesce(status, '')) = 'approved';

  if not found then
    raise exception 'Approved password reset request has already been used.';
  end if;

  select *
    into v_user
  from public.users u
  where u.id = v_user_id
  limit 1;

  if not found then
    raise exception 'User account not found.';
  end if;

  if v_session_auth_uid is not null then
    update public.users
       set auth_uid = v_session_auth_uid,
           updated_at = now()
     where id = v_user_id
       and (auth_uid is null or auth_uid = v_session_auth_uid);
  end if;

  select
    p.auth_uid,
    p.auth_email,
    p.auth_synced,
    p.created_auth_user
    into v_auth_uid,
         v_auth_email,
         v_auth_synced,
         v_created_auth_user
  from public.app_ensure_auth_user_for_password(
    p_user_id => v_user_id,
    p_password => p_new_password
  ) p
    limit 1;

  if not coalesce(v_auth_synced, false) then
    raise exception 'Failed to sync password to Supabase Auth.';
  end if;

  update public.account_requests
     set status = 'completed',
         resolved_by_user_id = v_user_id,
         resolved_at = now(),
         updated_at = now(),
         note = coalesce(note, 'Superseded by completed password reset.')
   where requester_user_id = v_user_id
     and lower(coalesce(request_type, '')) = 'password_reset'
     and lower(coalesce(status, '')) in ('pending', 'approved');

  perform public.app_log_status_event(
    p_action => 'password_reset_completed',
    p_category => 'request',
    p_message => format(
      'Password reset completed by "%s" after approval.',
      coalesce(v_user.full_name, v_user.username, v_user.id::text)
    ),
    p_actor_user_id => v_user.id,
    p_actor_username => v_user.username,
    p_actor_role => lower(coalesce(v_user.role, '')),
    p_target_user_id => v_user.id,
    p_target_username => v_user.username,
    p_target_role => lower(coalesce(v_user.role, '')),
    p_metadata => jsonb_build_object(
      'request_id', v_request.id,
      'auth_synced', coalesce(v_auth_synced, false),
      'auth_uid', v_auth_uid,
      'auth_email', v_auth_email,
      'created_auth_user', coalesce(v_created_auth_user, false)
    )
  );

  return true;
end;
$$;

create or replace function public.app_register_user(
  p_username text,
  p_password_hash text,
  p_full_name text,
  p_school_id text,
  p_role text default 'student',
  p_auth_uid uuid default null,
  p_expires_at timestamptz default null
)
returns table (
  id bigint,
  username text,
  full_name text,
  role text,
  roles jsonb,
  sub_role text,
  sub_roles jsonb,
  school_id text,
  image_path text,
  auth_uid uuid,
  expires_at timestamptz,
  created_at timestamptz,
  updated_at timestamptz
)
language plpgsql
security definer
set search_path = public, extensions
as $$
declare
  v_username text := trim(coalesce(p_username, ''));
  v_full_name text := trim(coalesce(p_full_name, ''));
  v_school_id text := trim(coalesce(p_school_id, ''));
  v_role text := lower(trim(coalesce(p_role, 'student')));
  v_hash text := coalesce(p_password_hash, '');
  v_generated_school_id text := null;
  v_attempt integer := 0;
  v_inserted public.users%rowtype;
begin
  if not public.app_is_admin() then
    raise exception 'Only administrators can create accounts.';
  end if;

  if v_username = '' then
    raise exception 'Username is required.';
  end if;
  if v_full_name = '' then
    raise exception 'Full name is required.';
  end if;
  if v_hash = '' then
    raise exception 'Password is required.';
  end if;

  if v_hash not like '$2a$%' and v_hash not like '$2b$%' and v_hash not like '$2y$%' then
    if length(v_hash) < 8 then
      raise exception 'Password must be at least 8 characters.';
    end if;
    v_hash := extensions.crypt(v_hash, extensions.gen_salt('bf', 12));
  end if;

  if v_role not in ('student', 'teacher', 'admin', 'nt') then
    raise exception 'Invalid role.';
  end if;

  if exists (
    select 1
    from public.users u
    where lower(u.username) = lower(v_username)
  ) then
    raise exception 'Username already exists.';
  end if;

  if v_school_id = '' then
    loop
      v_attempt := v_attempt + 1;
      if v_attempt > 500 then
        raise exception 'Unable to generate unique school ID.';
      end if;

      v_generated_school_id := format(
        '%s - %s',
        to_char(now(), 'YYYY'),
        lpad((floor(random() * 10000)::int)::text, 4, '0')
      );

      exit when not exists (
        select 1
        from public.users u
        where trim(coalesce(u.school_id, '')) = v_generated_school_id
      );
    end loop;

    v_school_id := v_generated_school_id;
  end if;

  insert into public.users (
    username,
    full_name,
    role,
    roles,
    sub_role,
    sub_roles,
    school_id,
    image_path,
    auth_uid,
    expires_at
  )
  values (
    v_username,
    v_full_name,
    v_role,
    jsonb_build_array(v_role),
    null,
    '[]'::jsonb,
    nullif(v_school_id, ''),
    '/images/sample.jpg',
    p_auth_uid,
    p_expires_at
  )
  returning * into v_inserted;

  perform 1
  from public.app_ensure_auth_user_for_hash(
    p_user_id => v_inserted.id,
    p_password_hash => v_hash
  ) p
  where coalesce(p.auth_synced, false)
  limit 1;

  if not found then
    raise exception 'Failed to provision secure auth profile for new account.';
  end if;

  select *
    into v_inserted
  from public.users u
  where u.id = v_inserted.id
  limit 1;

  return query
  select
    v_inserted.id,
    v_inserted.username,
    v_inserted.full_name,
    v_inserted.role,
    v_inserted.roles,
    v_inserted.sub_role,
    v_inserted.sub_roles,
    v_inserted.school_id,
    v_inserted.image_path,
    v_inserted.auth_uid,
    v_inserted.expires_at,
    v_inserted.created_at,
    v_inserted.updated_at;
end;
$$;

create or replace function public.app_admin_set_user_password(
  p_user_id bigint,
  p_new_password text
)
returns table (
  id bigint,
  auth_uid uuid,
  auth_synced boolean
)
language plpgsql
security definer
set search_path = public, auth, extensions
as $$
declare
  v_user public.users%rowtype;
  v_auth_uid uuid;
  v_auth_email text;
  v_auth_synced boolean := false;
  v_created_auth_user boolean := false;
begin
  if not public.app_is_admin() then
    raise exception 'Only administrators can reset passwords.';
  end if;

  if coalesce(p_user_id, 0) <= 0 then
    raise exception 'Invalid user id.';
  end if;

  if length(coalesce(p_new_password, '')) < 8 then
    raise exception 'Password must be at least 8 characters.';
  end if;

  select *
    into v_user
  from public.users u
  where u.id = p_user_id
  limit 1;

  if not found then
    raise exception 'User not found.';
  end if;

  select
    p.auth_uid,
    p.auth_email,
    p.auth_synced,
    p.created_auth_user
    into v_auth_uid,
         v_auth_email,
         v_auth_synced,
         v_created_auth_user
  from public.app_ensure_auth_user_for_password(
    p_user_id => p_user_id,
    p_password => p_new_password
  ) p
    limit 1;

  if not coalesce(v_auth_synced, false) then
    raise exception 'Failed to sync password to Supabase Auth.';
  end if;

  perform public.app_log_status_event(
    p_action => 'admin_password_reset_synced',
    p_category => 'account',
    p_message => format(
      'Admin synced secure auth password for "%s".',
      coalesce(v_user.full_name, v_user.username, v_user.id::text)
    ),
    p_actor_user_id => public.app_current_user_id(),
    p_target_user_id => v_user.id,
    p_target_username => v_user.username,
    p_target_role => lower(coalesce(v_user.role, '')),
    p_metadata => jsonb_build_object(
      'auth_uid', v_auth_uid,
      'auth_email', v_auth_email,
      'created_auth_user', coalesce(v_created_auth_user, false),
      'auth_synced', coalesce(v_auth_synced, false)
    )
  );

  return query
  select p_user_id, v_auth_uid, coalesce(v_auth_synced, false);
end;
$$;

revoke execute on function public.app_log_status_event(text, text, text, bigint, text, text, bigint, text, text, jsonb) from anon;
grant execute on function public.app_log_status_event(text, text, text, bigint, text, text, bigint, text, text, jsonb) to authenticated;

revoke execute on function public.app_register_user(text, text, text, text, text, uuid, timestamptz) from anon;
grant execute on function public.app_register_user(text, text, text, text, text, uuid, timestamptz) to authenticated;

-- ---------------------------------------------------------------------------
-- FINAL AUTH HOTFIX OVERRIDE (authoritative last definitions)
-- ---------------------------------------------------------------------------
-- Keeps this file self-healing even if earlier duplicate definitions remain.

create or replace function public.app_ensure_auth_user_for_password(
  p_user_id bigint,
  p_password text
)
returns table (
  auth_uid uuid,
  auth_email text,
  auth_synced boolean,
  created_auth_user boolean
)
language plpgsql
security definer
set search_path = public, auth, extensions
as $$
declare
  v_user public.users%rowtype;
  v_auth_uid uuid;
  v_auth_email text;
  v_existing_auth_email text;
  v_instance_id uuid := null;
  v_created_auth_user boolean := false;
  v_synced boolean := false;
begin
  if coalesce(p_user_id, 0) <= 0 then
    raise exception 'Invalid user id.';
  end if;

  if length(coalesce(p_password, '')) < 8 then
    raise exception 'Password must be at least 8 characters.';
  end if;

  select *
    into v_user
  from public.users u
  where u.id = p_user_id
  limit 1;

  if not found then
    raise exception 'User not found.';
  end if;

  v_auth_uid := v_user.auth_uid;
  v_auth_email := public.app_username_auth_email(v_user.username, v_user.id);

  begin
    select i.id
      into v_instance_id
    from auth.instances i
    order by i.id
    limit 1;
  exception
    when undefined_table then
      v_instance_id := null;
  end;

  if v_instance_id is null then
    begin
      select au.instance_id
        into v_instance_id
      from auth.users au
      where au.instance_id is not null
      order by au.created_at
      limit 1;
    exception
      when undefined_column then
        v_instance_id := null;
    end;
  end if;

  if v_instance_id is null then
    v_instance_id := '00000000-0000-0000-0000-000000000000'::uuid;
  end if;

  if v_auth_uid is not null then
    select lower(coalesce(au.email, ''))
      into v_existing_auth_email
    from auth.users au
    where au.id = v_auth_uid
    limit 1;

    if not found then
      v_auth_uid := null;
    elsif coalesce(v_existing_auth_email, '') <> lower(coalesce(v_auth_email, '')) then
      -- Stale/mismatched linkage: relink using canonical username email.
      v_auth_uid := null;
    end if;
  end if;

  if v_auth_uid is null then
    select au.id
      into v_auth_uid
    from auth.users au
    where lower(coalesce(au.email, '')) = lower(coalesce(v_auth_email, ''))
    order by au.created_at
    limit 1;
  end if;

  if v_auth_uid is null then
    v_auth_uid := gen_random_uuid();

    begin
      insert into auth.users (
        id,
        instance_id,
        aud,
        role,
        email,
        encrypted_password,
        email_confirmed_at,
        raw_app_meta_data,
        raw_user_meta_data,
        created_at,
        updated_at
      )
      values (
        v_auth_uid,
        v_instance_id,
        'authenticated',
        'authenticated',
        v_auth_email,
        crypt(p_password, gen_salt('bf', 10)),
        now(),
        '{"provider":"email","providers":["email"]}'::jsonb,
        '{}'::jsonb,
        now(),
        now()
      );
      v_created_auth_user := true;
    exception
      when unique_violation then
        select au.id
          into v_auth_uid
        from auth.users au
        where lower(coalesce(au.email, '')) = lower(coalesce(v_auth_email, ''))
        order by au.created_at
        limit 1;
        if v_auth_uid is null then
          raise;
        end if;
    end;
  end if;

  begin
    update auth.identities ai
       set provider_id = lower(v_auth_email),
           identity_data = jsonb_build_object(
             'sub', v_auth_uid::text,
             'email', v_auth_email,
             'email_verified', true,
             'phone_verified', false
           ),
           last_sign_in_at = coalesce(ai.last_sign_in_at, now()),
           updated_at = now()
     where ai.user_id = v_auth_uid
       and ai.provider = 'email';

    if not found then
      insert into auth.identities (
        id,
        user_id,
        provider_id,
        identity_data,
        provider,
        last_sign_in_at,
        created_at,
        updated_at
      )
      values (
        gen_random_uuid(),
        v_auth_uid,
        lower(v_auth_email),
        jsonb_build_object(
          'sub', v_auth_uid::text,
          'email', v_auth_email,
          'email_verified', true,
          'phone_verified', false
        ),
        'email',
        now(),
        now(),
        now()
      )
      on conflict do nothing;
    end if;
  exception
    when undefined_table or undefined_column then
      null;
  end;

  update auth.users au
     set instance_id = coalesce(v_instance_id, au.instance_id),
         aud = 'authenticated',
         role = 'authenticated',
         encrypted_password = crypt(p_password, gen_salt('bf', 10)),
         email = coalesce(nullif(v_auth_email, ''), au.email),
         email_confirmed_at = coalesce(au.email_confirmed_at, now()),
         updated_at = now()
   where au.id = v_auth_uid;
  v_synced := found;

  if coalesce(v_synced, false) then
    begin
      execute 'update auth.users set deleted_at = null where id = $1' using v_auth_uid;
    exception
      when undefined_column then
        null;
    end;
    begin
      execute 'update auth.users set banned_until = null where id = $1' using v_auth_uid;
    exception
      when undefined_column then
        null;
    end;
    begin
      execute 'update auth.users set is_sso_user = false where id = $1' using v_auth_uid;
    exception
      when undefined_column then
        null;
    end;
  end if;

  update public.users
     set auth_uid = v_auth_uid,
         updated_at = now()
   where id = p_user_id;

  return query
  select
    v_auth_uid,
    nullif(v_auth_email, ''),
    coalesce(v_synced, false),
    coalesce(v_created_auth_user, false);
end;
$$;

create or replace function public.app_ensure_auth_user_for_hash(
  p_user_id bigint,
  p_password_hash text default null
)
returns table (
  auth_uid uuid,
  auth_email text,
  auth_synced boolean,
  created_auth_user boolean
)
language plpgsql
security definer
set search_path = public, auth, extensions
as $$
declare
  v_user public.users%rowtype;
  v_auth_uid uuid;
  v_auth_email text;
  v_existing_auth_email text;
  v_hash text := trim(coalesce(p_password_hash, ''));
  v_hash_for_auth text;
  v_instance_id uuid := null;
  v_created_auth_user boolean := false;
  v_synced boolean := false;
begin
  if coalesce(p_user_id, 0) <= 0 then
    raise exception 'Invalid user id.';
  end if;

  select *
    into v_user
  from public.users u
  where u.id = p_user_id
  limit 1;

  if not found then
    raise exception 'User not found.';
  end if;

  if v_hash = '' then
    v_hash := trim(coalesce(v_user.password, ''));
  end if;

  if v_hash = '' then
    raise exception 'Password hash is required.';
  end if;

  if v_hash not like '$2a$%' and v_hash not like '$2b$%' and v_hash not like '$2y$%' then
    raise exception 'Password hash must be a bcrypt hash.';
  end if;

  v_hash_for_auth := v_hash;
  if v_hash_for_auth like '$2y$%' then
    v_hash_for_auth := replace(v_hash_for_auth, '$2y$', '$2a$');
  end if;
  if v_hash_for_auth like '$2b$%' then
    v_hash_for_auth := replace(v_hash_for_auth, '$2b$', '$2a$');
  end if;

  v_auth_uid := v_user.auth_uid;
  v_auth_email := public.app_username_auth_email(v_user.username, v_user.id);

  begin
    select i.id
      into v_instance_id
    from auth.instances i
    order by i.id
    limit 1;
  exception
    when undefined_table then
      v_instance_id := null;
  end;

  if v_instance_id is null then
    begin
      select au.instance_id
        into v_instance_id
      from auth.users au
      where au.instance_id is not null
      order by au.created_at
      limit 1;
    exception
      when undefined_column then
        v_instance_id := null;
    end;
  end if;

  if v_instance_id is null then
    v_instance_id := '00000000-0000-0000-0000-000000000000'::uuid;
  end if;

  if v_auth_uid is not null then
    select lower(coalesce(au.email, ''))
      into v_existing_auth_email
    from auth.users au
    where au.id = v_auth_uid
    limit 1;

    if not found then
      v_auth_uid := null;
    elsif coalesce(v_existing_auth_email, '') <> lower(coalesce(v_auth_email, '')) then
      v_auth_uid := null;
    end if;
  end if;

  if v_auth_uid is null then
    select au.id
      into v_auth_uid
    from auth.users au
    where lower(coalesce(au.email, '')) = lower(coalesce(v_auth_email, ''))
    order by au.created_at
    limit 1;
  end if;

  if v_auth_uid is null then
    v_auth_uid := gen_random_uuid();

    begin
      insert into auth.users (
        id,
        instance_id,
        aud,
        role,
        email,
        encrypted_password,
        email_confirmed_at,
        raw_app_meta_data,
        raw_user_meta_data,
        created_at,
        updated_at
      )
      values (
        v_auth_uid,
        v_instance_id,
        'authenticated',
        'authenticated',
        v_auth_email,
        v_hash_for_auth,
        now(),
        '{"provider":"email","providers":["email"]}'::jsonb,
        '{}'::jsonb,
        now(),
        now()
      );
      v_created_auth_user := true;
    exception
      when unique_violation then
        select au.id
          into v_auth_uid
        from auth.users au
        where lower(coalesce(au.email, '')) = lower(coalesce(v_auth_email, ''))
        order by au.created_at
        limit 1;
        if v_auth_uid is null then
          raise;
        end if;
    end;
  end if;

  begin
    update auth.identities ai
       set provider_id = lower(v_auth_email),
           identity_data = jsonb_build_object(
             'sub', v_auth_uid::text,
             'email', v_auth_email,
             'email_verified', true,
             'phone_verified', false
           ),
           last_sign_in_at = coalesce(ai.last_sign_in_at, now()),
           updated_at = now()
     where ai.user_id = v_auth_uid
       and ai.provider = 'email';

    if not found then
      insert into auth.identities (
        id,
        user_id,
        provider_id,
        identity_data,
        provider,
        last_sign_in_at,
        created_at,
        updated_at
      )
      values (
        gen_random_uuid(),
        v_auth_uid,
        lower(v_auth_email),
        jsonb_build_object(
          'sub', v_auth_uid::text,
          'email', v_auth_email,
          'email_verified', true,
          'phone_verified', false
        ),
        'email',
        now(),
        now(),
        now()
      )
      on conflict do nothing;
    end if;
  exception
    when undefined_table or undefined_column then
      null;
  end;

  update auth.users au
     set instance_id = coalesce(v_instance_id, au.instance_id),
         aud = 'authenticated',
         role = 'authenticated',
         encrypted_password = v_hash_for_auth,
         email = coalesce(nullif(v_auth_email, ''), au.email),
         email_confirmed_at = coalesce(au.email_confirmed_at, now()),
         updated_at = now()
   where au.id = v_auth_uid;
  v_synced := found;

  if coalesce(v_synced, false) then
    begin
      execute 'update auth.users set deleted_at = null where id = $1' using v_auth_uid;
    exception
      when undefined_column then
        null;
    end;
    begin
      execute 'update auth.users set banned_until = null where id = $1' using v_auth_uid;
    exception
      when undefined_column then
        null;
    end;
    begin
      execute 'update auth.users set is_sso_user = false where id = $1' using v_auth_uid;
    exception
      when undefined_column then
        null;
    end;
  end if;

  update public.users
     set auth_uid = v_auth_uid,
         updated_at = now()
   where id = p_user_id;

  return query
  select
    v_auth_uid,
    nullif(v_auth_email, ''),
    coalesce(v_synced, false),
    coalesce(v_created_auth_user, false);
end;
$$;

create or replace function public.app_password_matches_user(
  p_user_id bigint,
  p_password text
)
returns boolean
language sql
stable
security definer
set search_path = public, auth, extensions
as $$
  with target_user as (
    select
      u.id,
      u.auth_uid,
      coalesce(u.password, '') as legacy_password,
      lower(public.app_username_auth_email(u.username, u.id)) as auth_email
    from public.users u
    where u.id = p_user_id
    limit 1
  ),
  ranked_auth as (
    select
      au.encrypted_password,
      row_number() over (
        order by
          case
            when tu.auth_uid is not null
                 and au.id = tu.auth_uid
                 and lower(coalesce(au.email, '')) = tu.auth_email then 0
            when lower(coalesce(au.email, '')) = tu.auth_email then 1
            when tu.auth_uid is not null and au.id = tu.auth_uid then 2
            else 9
          end,
          au.created_at desc nulls last
      ) as rn
    from target_user tu
    join auth.users au
      on (
        lower(coalesce(au.email, '')) = tu.auth_email
        or (tu.auth_uid is not null and au.id = tu.auth_uid)
      )
  ),
  picked_auth as (
    select ra.encrypted_password
    from ranked_auth ra
    where ra.rn = 1
    limit 1
  ),
  auth_match as (
    select
      coalesce(pa.encrypted_password, '') <> ''
      and (
        pa.encrypted_password = crypt(coalesce(p_password, ''), pa.encrypted_password)
        or (
          pa.encrypted_password like '$2y$%'
          and replace(pa.encrypted_password, '$2y$', '$2a$')
            = crypt(
                coalesce(p_password, ''),
                replace(pa.encrypted_password, '$2y$', '$2a$')
              )
        )
        or (
          pa.encrypted_password like '$2b$%'
          and replace(pa.encrypted_password, '$2b$', '$2a$')
            = crypt(
                coalesce(p_password, ''),
                replace(pa.encrypted_password, '$2b$', '$2a$')
              )
        )
      ) as ok
    from picked_auth pa
    limit 1
  ),
  legacy_match as (
    select
      coalesce(tu.legacy_password, '') <> ''
      and (
        tu.legacy_password = crypt(coalesce(p_password, ''), tu.legacy_password)
        or (
          tu.legacy_password like '$2y$%'
          and replace(tu.legacy_password, '$2y$', '$2a$')
            = crypt(
                coalesce(p_password, ''),
                replace(tu.legacy_password, '$2y$', '$2a$')
              )
        )
        or (
          tu.legacy_password like '$2b$%'
          and replace(tu.legacy_password, '$2b$', '$2a$')
            = crypt(
                coalesce(p_password, ''),
                replace(tu.legacy_password, '$2b$', '$2a$')
              )
        )
        or (
          tu.legacy_password not like '$2%'
          and tu.legacy_password = coalesce(p_password, '')
        )
      ) as ok
    from target_user tu
    limit 1
  )
  select
    coalesce((select ok from auth_match limit 1), false)
    or coalesce((select ok from legacy_match limit 1), false);
$$;

create or replace function public.app_login(
  p_identifier text,
  p_password text
)
returns table (
  id bigint,
  username text,
  full_name text,
  role text,
  roles jsonb,
  sub_role text,
  sub_roles jsonb,
  school_id text,
  image_path text,
  auth_uid uuid,
  auth_email text,
  created_at timestamptz,
  updated_at timestamptz
)
language sql
security definer
set search_path = public, auth, extensions
as $$
  with target_user as (
    select
      u.*,
      lower(public.app_username_auth_email(u.username, u.id)) as canonical_auth_email
    from public.users u
    where lower(trim(coalesce(u.username, ''))) = lower(trim(coalesce(p_identifier, '')))
      and public.app_password_matches_user(u.id, coalesce(p_password, ''))
      and (u.expires_at is null or u.expires_at > now())
  )
  select
    u.id,
    u.username,
    u.full_name,
    u.role,
    u.roles,
    u.sub_role,
    u.sub_roles,
    u.school_id,
    u.image_path,
    u.auth_uid,
    case
      when lower(trim(coalesce(au.email, ''))) = u.canonical_auth_email
        then lower(trim(coalesce(au.email, '')))
      else u.canonical_auth_email
    end as auth_email,
    u.created_at,
    u.updated_at
  from target_user u
  left join auth.users au
    on au.id = u.auth_uid
  order by
    case
      when u.auth_uid is not null
           and lower(trim(coalesce(au.email, ''))) = u.canonical_auth_email then 0
      when u.auth_uid is not null then 1
      else 2
    end,
    coalesce(u.updated_at, u.created_at, to_timestamp(0)) desc,
    u.id desc
  limit 1;
$$;

create or replace function public.app_repair_auth_profile_for_login(
  p_identifier text,
  p_password text
)
returns table (
  auth_uid uuid,
  auth_email text,
  auth_synced boolean,
  created_auth_user boolean
)
language plpgsql
security definer
set search_path = public, auth, extensions
as $$
declare
  v_identifier text := trim(coalesce(p_identifier, ''));
  v_password text := coalesce(p_password, '');
  v_user_id bigint;
  v_expected_email text;
begin
  if v_identifier = '' or v_password = '' then
    return;
  end if;

  select
    u.id,
    public.app_username_auth_email(u.username, u.id)
  into v_user_id, v_expected_email
  from public.users u
  where lower(trim(coalesce(u.username, ''))) = lower(v_identifier)
    and (u.expires_at is null or u.expires_at > now())
    and public.app_password_matches_user(u.id, v_password)
  order by
    case when u.auth_uid is not null then 0 else 1 end,
    coalesce(u.updated_at, u.created_at, to_timestamp(0)) desc,
    u.id desc
  limit 1;

  if not found then
    return;
  end if;

  update public.users u
     set auth_uid = null,
         updated_at = now()
   where u.id = v_user_id
     and u.auth_uid is not null
     and (
       not exists (
         select 1
         from auth.users au
         where au.id = u.auth_uid
       )
       or exists (
         select 1
         from auth.users au
         where au.id = u.auth_uid
           and lower(coalesce(au.email, '')) <> lower(coalesce(v_expected_email, ''))
       )
     );

  return query
  select
    p.auth_uid,
    p.auth_email,
    p.auth_synced,
    p.created_auth_user
  from public.app_ensure_auth_user_for_password(
    p_user_id => v_user_id,
    p_password => v_password
  ) p
  limit 1;
end;
$$;

grant execute on function public.app_login(text, text) to anon, authenticated;
grant execute on function public.app_password_matches_user(bigint, text) to authenticated;
grant execute on function public.app_repair_auth_profile_for_login(text, text) to anon, authenticated;
grant execute on function public.app_ensure_auth_user_for_password(bigint, text) to authenticated;
grant execute on function public.app_ensure_auth_user_for_hash(bigint, text) to authenticated;

do $$
begin
  perform pg_notify('pgrst', 'reload schema');
exception
  when undefined_function then
    null;
end $$;

-- ---------------------------------------------------------------------------
-- FINAL AUTH-ONLY OVERRIDE V2 (must stay last)
-- ---------------------------------------------------------------------------
-- Auth authority is Supabase Auth only.
-- public.users is profile/role storage only.

create or replace function public.app_password_matches_user(
  p_user_id bigint,
  p_password text
)
returns boolean
language sql
stable
security definer
set search_path = public, auth, extensions
as $$
  with target_user as (
    select
      u.id,
      u.auth_uid,
      lower(public.app_username_auth_email(u.username, u.id)) as auth_email
    from public.users u
    where u.id = p_user_id
    limit 1
  ),
  ranked_auth as (
    select
      au.encrypted_password,
      row_number() over (
        order by
          case
            when tu.auth_uid is not null and au.id = tu.auth_uid then 0
            when lower(coalesce(au.email, '')) = tu.auth_email then 1
            else 9
          end,
          au.created_at desc nulls last
      ) as rn
    from target_user tu
    join auth.users au
      on (
        (tu.auth_uid is not null and au.id = tu.auth_uid)
        or lower(coalesce(au.email, '')) = tu.auth_email
      )
  ),
  chosen as (
    select ra.encrypted_password
    from ranked_auth ra
    where ra.rn = 1
    limit 1
  )
  select coalesce(
    (
      select
        coalesce(c.encrypted_password, '') <> ''
        and (
          c.encrypted_password = crypt(coalesce(p_password, ''), c.encrypted_password)
          or (
            c.encrypted_password like '$2y$%'
            and replace(c.encrypted_password, '$2y$', '$2a$')
              = crypt(
                  coalesce(p_password, ''),
                  replace(c.encrypted_password, '$2y$', '$2a$')
                )
          )
          or (
            c.encrypted_password like '$2b$%'
            and replace(c.encrypted_password, '$2b$', '$2a$')
              = crypt(
                  coalesce(p_password, ''),
                  replace(c.encrypted_password, '$2b$', '$2a$')
                )
          )
        )
      from chosen c
      limit 1
    ),
    false
  );
$$;

create or replace function public.app_login(
  p_identifier text,
  p_password text
)
returns table (
  id bigint,
  username text,
  full_name text,
  role text,
  roles jsonb,
  sub_role text,
  sub_roles jsonb,
  school_id text,
  image_path text,
  auth_uid uuid,
  auth_email text,
  created_at timestamptz,
  updated_at timestamptz
)
language sql
security definer
set search_path = public, auth, extensions
as $$
  with target_user as (
    select
      u.*,
      lower(public.app_username_auth_email(u.username, u.id)) as canonical_auth_email
    from public.users u
    where lower(trim(coalesce(u.username, ''))) = lower(trim(coalesce(p_identifier, '')))
      and (u.expires_at is null or u.expires_at > now())
    order by
      case when u.auth_uid is not null then 0 else 1 end,
      coalesce(u.updated_at, u.created_at, to_timestamp(0)) desc,
      u.id desc
    limit 1
  ),
  ranked_auth as (
    select
      au.id as resolved_auth_uid,
      lower(trim(coalesce(au.email, ''))) as resolved_auth_email,
      au.encrypted_password,
      row_number() over (
        order by
          case
            when tu.auth_uid is not null and au.id = tu.auth_uid then 0
            when lower(coalesce(au.email, '')) = tu.canonical_auth_email then 1
            else 9
          end,
          au.created_at desc nulls last
      ) as rn
    from target_user tu
    join auth.users au
      on (
        (tu.auth_uid is not null and au.id = tu.auth_uid)
        or lower(coalesce(au.email, '')) = tu.canonical_auth_email
      )
  ),
  matched_auth as (
    select
      ra.resolved_auth_uid,
      ra.resolved_auth_email
    from ranked_auth ra
    where ra.rn = 1
      and coalesce(ra.encrypted_password, '') <> ''
      and (
        ra.encrypted_password = crypt(coalesce(p_password, ''), ra.encrypted_password)
        or (
          ra.encrypted_password like '$2y$%'
          and replace(ra.encrypted_password, '$2y$', '$2a$')
            = crypt(
                coalesce(p_password, ''),
                replace(ra.encrypted_password, '$2y$', '$2a$')
              )
        )
        or (
          ra.encrypted_password like '$2b$%'
          and replace(ra.encrypted_password, '$2b$', '$2a$')
            = crypt(
                coalesce(p_password, ''),
                replace(ra.encrypted_password, '$2b$', '$2a$')
              )
        )
      )
    limit 1
  )
  select
    tu.id,
    tu.username,
    tu.full_name,
    tu.role,
    tu.roles,
    tu.sub_role,
    tu.sub_roles,
    tu.school_id,
    tu.image_path,
    coalesce(ma.resolved_auth_uid, tu.auth_uid) as auth_uid,
    coalesce(nullif(ma.resolved_auth_email, ''), tu.canonical_auth_email) as auth_email,
    tu.created_at,
    tu.updated_at
  from target_user tu
  join matched_auth ma
    on true
  limit 1;
$$;

create or replace function public.app_register_user(
  p_username text,
  p_password_hash text,
  p_full_name text,
  p_school_id text,
  p_role text default 'student',
  p_auth_uid uuid default null,
  p_expires_at timestamptz default null
)
returns table (
  id bigint,
  username text,
  full_name text,
  role text,
  roles jsonb,
  sub_role text,
  sub_roles jsonb,
  school_id text,
  image_path text,
  auth_uid uuid,
  expires_at timestamptz,
  created_at timestamptz,
  updated_at timestamptz
)
language plpgsql
security definer
set search_path = public, extensions
as $$
declare
  v_username text := trim(coalesce(p_username, ''));
  v_full_name text := trim(coalesce(p_full_name, ''));
  v_school_id text := trim(coalesce(p_school_id, ''));
  v_role text := lower(trim(coalesce(p_role, 'student')));
  v_password_input text := coalesce(p_password_hash, '');
  v_generated_school_id text := null;
  v_attempt integer := 0;
  v_inserted public.users%rowtype;
begin
  if not public.app_is_admin() then
    raise exception 'Only administrators can create accounts.';
  end if;

  if v_username = '' then
    raise exception 'Username is required.';
  end if;
  if v_full_name = '' then
    raise exception 'Full name is required.';
  end if;

  if v_password_input = '' then
    raise exception 'Password is required.';
  end if;
  if v_password_input not like '$2a$%' and v_password_input not like '$2b$%' and v_password_input not like '$2y$%' then
    if length(v_password_input) < 8 then
      raise exception 'Password must be at least 8 characters.';
    end if;
  end if;

  if v_role not in ('student', 'teacher', 'admin', 'nt') then
    raise exception 'Invalid role.';
  end if;

  if exists (
    select 1
    from public.users u
    where lower(u.username) = lower(v_username)
  ) then
    raise exception 'Username already exists.';
  end if;

  if v_school_id = '' then
    loop
      v_attempt := v_attempt + 1;
      if v_attempt > 500 then
        raise exception 'Unable to generate unique school ID.';
      end if;

      v_generated_school_id := format(
        '%s - %s',
        to_char(now(), 'YYYY'),
        lpad((floor(random() * 10000)::int)::text, 4, '0')
      );

      exit when not exists (
        select 1
        from public.users u
        where trim(coalesce(u.school_id, '')) = v_generated_school_id
      );
    end loop;

    v_school_id := v_generated_school_id;
  end if;

  insert into public.users (
    username,
    full_name,
    role,
    roles,
    sub_role,
    sub_roles,
    school_id,
    image_path,
    auth_uid,
    expires_at
  )
  values (
    v_username,
    v_full_name,
    v_role,
    jsonb_build_array(v_role),
    null,
    '[]'::jsonb,
    nullif(v_school_id, ''),
    '/images/sample.jpg',
    p_auth_uid,
    p_expires_at
  )
  returning * into v_inserted;

  return query
  select
    v_inserted.id,
    v_inserted.username,
    v_inserted.full_name,
    v_inserted.role,
    v_inserted.roles,
    v_inserted.sub_role,
    v_inserted.sub_roles,
    v_inserted.school_id,
    v_inserted.image_path,
    v_inserted.auth_uid,
    v_inserted.expires_at,
    v_inserted.created_at,
    v_inserted.updated_at;
end;
$$;

create or replace function public.app_admin_set_user_password(
  p_user_id bigint,
  p_new_password text
)
returns table (
  id bigint,
  auth_uid uuid,
  auth_synced boolean
)
language plpgsql
security definer
set search_path = public
as $$
begin
  raise exception 'Password reset must use set-auth-password edge function (auth.admin flow).';
end;
$$;

revoke execute on function public.app_admin_set_user_password(bigint, text) from anon;
revoke execute on function public.app_admin_set_user_password(bigint, text) from authenticated;
grant execute on function public.app_login(text, text) to anon, authenticated;
grant execute on function public.app_password_matches_user(bigint, text) to authenticated;
grant execute on function public.app_register_user(text, text, text, text, text, uuid, timestamptz) to authenticated;

do $$
begin
  perform pg_notify('pgrst', 'reload schema');
exception
  when undefined_function then
    null;
end $$;

-- ---------------------------------------------------------------------------
-- AUTH-ONLY HARDENING GRANTS V3 (must stay last)
-- ---------------------------------------------------------------------------
revoke execute on function public.app_admin_set_user_password(bigint, text) from anon;
revoke execute on function public.app_admin_set_user_password(bigint, text) from authenticated;
revoke execute on function public.app_repair_auth_profile_for_login(text, text) from anon;
revoke execute on function public.app_repair_auth_profile_for_login(text, text) from authenticated;
revoke execute on function public.app_ensure_auth_user_for_password(bigint, text) from authenticated;
revoke execute on function public.app_ensure_auth_user_for_hash(bigint, text) from authenticated;

grant execute on function public.app_login(text, text) to anon, authenticated;
grant execute on function public.app_password_matches_user(bigint, text) to authenticated;
grant execute on function public.app_register_user(text, text, text, text, text, uuid, timestamptz) to authenticated;

do $$
begin
  perform pg_notify('pgrst', 'reload schema');
exception
  when undefined_function then
    null;
end $$;

-- ---------------------------------------------------------------------------
-- PASSWORD RESET COMPLETE ONE-TIME ENFORCEMENT V6 (final tail)
-- ---------------------------------------------------------------------------
create or replace function public.app_complete_approved_password_reset(
  p_new_password text
)
returns boolean
language plpgsql
security definer
set search_path = public, auth, extensions
as $$
declare
  v_user_id bigint := public.app_current_user_id();
  v_session_auth_uid uuid := auth.uid();
  v_user public.users%rowtype;
  v_request public.account_requests%rowtype;
  v_auth_uid uuid;
  v_auth_email text;
  v_auth_synced boolean := false;
  v_created_auth_user boolean := false;
begin
  if v_user_id is null then
    raise exception 'Not authenticated.';
  end if;

  if length(coalesce(p_new_password, '')) < 8 then
    raise exception 'Password must be at least 8 characters.';
  end if;

  select *
    into v_request
  from public.account_requests r
  where r.requester_user_id = v_user_id
    and lower(trim(coalesce(r.request_type, ''))) = 'password_reset'
    and lower(trim(coalesce(r.status, ''))) = 'approved'
  order by coalesce(r.updated_at, r.created_at, to_timestamp(0)) desc, r.id desc
  limit 1
  for update;

  if not found then
    raise exception 'No approved password reset request found.';
  end if;

  update public.account_requests
     set status = 'completed',
         resolved_by_user_id = v_user_id,
         resolved_at = now(),
         updated_at = now(),
         note = coalesce(note, 'Approved request completed by requester.')
   where id = v_request.id
     and lower(trim(coalesce(status, ''))) = 'approved';

  if not found then
    raise exception 'Approved password reset request has already been used.';
  end if;

  select *
    into v_user
  from public.users u
  where u.id = v_user_id
  limit 1;

  if not found then
    raise exception 'User account not found.';
  end if;

  if v_session_auth_uid is not null then
    update public.users
       set auth_uid = v_session_auth_uid,
           updated_at = now()
     where id = v_user_id
       and (auth_uid is null or auth_uid = v_session_auth_uid);
  end if;

  select
    p.auth_uid,
    p.auth_email,
    p.auth_synced,
    p.created_auth_user
    into v_auth_uid,
         v_auth_email,
         v_auth_synced,
         v_created_auth_user
  from public.app_ensure_auth_user_for_password(
    p_user_id => v_user_id,
    p_password => p_new_password
  ) p
  limit 1;

  if not coalesce(v_auth_synced, false) then
    raise exception 'Failed to sync password to Supabase Auth.';
  end if;

  update public.account_requests
     set status = 'completed',
         resolved_by_user_id = v_user_id,
         resolved_at = now(),
         updated_at = now(),
         note = coalesce(note, 'Superseded by completed password reset.')
   where requester_user_id = v_user_id
     and lower(trim(coalesce(request_type, ''))) = 'password_reset'
     and lower(trim(coalesce(status, ''))) in ('pending', 'approved');

  perform public.app_log_status_event(
    p_action => 'password_reset_completed',
    p_category => 'request',
    p_message => format(
      'Password reset completed by "%s" after approval.',
      coalesce(v_user.full_name, v_user.username, v_user.id::text)
    ),
    p_actor_user_id => v_user.id,
    p_actor_username => v_user.username,
    p_actor_role => lower(trim(coalesce(v_user.role, ''))),
    p_target_user_id => v_user.id,
    p_target_username => v_user.username,
    p_target_role => lower(trim(coalesce(v_user.role, ''))),
    p_metadata => jsonb_build_object(
      'request_id', v_request.id,
      'auth_synced', coalesce(v_auth_synced, false),
      'auth_uid', v_auth_uid,
      'auth_email', v_auth_email,
      'created_auth_user', coalesce(v_created_auth_user, false)
    )
  );

  return true;
end;
$$;

grant execute on function public.app_complete_approved_password_reset(text) to authenticated;

do $$
begin
  perform pg_notify('pgrst', 'reload schema');
exception
  when undefined_function then
    null;
end $$;
